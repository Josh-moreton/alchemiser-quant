# yaml-language-server: $schema=https://raw.githubusercontent.com/aws/serverless-application-model/main/samtranslator/validator/sam_schema/schema.json
# yaml-language-server: disable-validation
AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: >
  The Alchemiser Quantitative Trading System

  Multi-strategy algorithmic trading engine deployed as an AWS Lambda Function

Parameters:
  Stage:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - staging
      - prod
      - ephemeral
    Description: Deployment stage (dev, staging, prod, or ephemeral)
  
  StackName:
    Type: String
    Default: ""
    Description: Optional override for stack-specific resource naming (used for ephemeral stacks)
  
  Env:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - staging
      - prod
      - ephemeral
    Description: Environment type for resource configuration
  
  ArtifactPrefix:
    Type: String
    Default: ""
    Description: S3 prefix for artifacts (used for ephemeral stack isolation)

  # Cross-stack references: names of the deployed shared and data stacks
  SharedStackName:
    Type: String
    Description: CloudFormation stack name of the shared infrastructure stack (for cross-stack imports)

  DataStackName:
    Type: String
    Description: CloudFormation stack name of the data/dashboard stack (for cross-stack imports)

  AlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key (used only in dev; leave blank for prod)

  AlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret (used only in dev; leave blank for prod)

  AlpacaEndpoint:
    Type: String
    Default: https://paper-api.alpaca.markets/v2
    Description: Alpaca API endpoint; defaults to paper for dev, live is used for prod

  # Margin/Leverage configuration
  EquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: ALPACA__EQUITY_DEPLOYMENT_PCT - percentage of equity to deploy (1.0=100%, 1.10=110% with margin)

  ProdEquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: Equity deployment percentage for production (conservative default)

  # Staging-only parameters (only used when Stage=staging)
  StagingAlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key for staging (required when Stage=staging)

  StagingAlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret for staging (required when Stage=staging)

  StagingAlpacaEndpoint:
    Type: String
    Default: https://paper-api.alpaca.markets/v2
    Description: Alpaca API endpoint for staging (typically paper trading)

  StagingEquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: Equity deployment percentage for staging

  # Production-only parameters (only used when Stage=prod)
  ProdAlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key for production (required when Stage=prod)

  ProdAlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret for production (required when Stage=prod)

  ProdAlpacaEndpoint:
    Type: String
    Default: https://api.alpaca.markets
    Description: Alpaca API endpoint for production

  # Notification email (kept for backward compatibility; also in shared stack)
  NotificationEmail:
    Type: String
    Default: ""
    Description: Email address for success notifications (set per-environment in secret store)

  FailureNotificationEmail:
    Type: String
    Default: ""
    Description: Email address for failure/warning notifications (defaults to josh@rwxt.org)

Mappings:
  StageConfig:
    dev:
      TitleCase: "Dev"
    staging:
      TitleCase: "Staging"
    prod:
      TitleCase: "Production"
    ephemeral:
      TitleCase: "Ephemeral"

Conditions:
  IsStaging: !Equals [ !Ref Stage, staging ]
  IsProduction: !Equals [ !Ref Stage, prod ]
  IsEphemeral: !Equals [ !Ref Stage, ephemeral ]
  HasStackName: !Not [ !Equals [ !Ref StackName, "" ] ]
  UseStackNameForResources: !Or [ !Condition IsEphemeral, !Condition HasStackName ]
  HasNotificationEmail: !Not [ !Equals [ !Ref NotificationEmail, "" ] ]
  HasFailureNotificationEmail: !Not [ !Equals [ !Ref FailureNotificationEmail, "" ] ]

Globals:
  Function:
    Timeout: 900 # 15 minutes - max for Lambda
    MemorySize: 512
    Environment:
      Variables:
        # Stage awareness for code-level profiles
        APP__STAGE: !If [ IsProduction, "prod", !If [ IsStaging, "staging", "dev" ] ]
        # Alpaca Configuration
        ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
        ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
        ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
        # Strategy DSL configuration now comes from code defaults; override via env only if necessary
        # STRATEGY__DSL_FILES: '["1-KMLM.clj","2-Nuclear.clj","5-Coin.clj","6-TQQQ-FLT.clj"]'
        # STRATEGY__DSL_ALLOCATIONS: '{"1-KMLM.clj":0.4,"2-Nuclear.clj":0.25,"5-Coin.clj":0.1,"6-TQQQ-FLT.clj":0.25}'

        # Margin/Leverage configuration - controls how much of equity to deploy
        # 1.0 = 100% of equity (no margin), 1.10 = 110% (10% margin usage)
        ALPACA__EQUITY_DEPLOYMENT_PCT: !If [ IsProduction, !Ref ProdEquityDeploymentPct, !If [ IsStaging, !Ref StagingEquityDeploymentPct, !Ref EquityDeploymentPct ] ]

        # Trade ledger DynamoDB table (from shared stack)
        TRADE_LEDGER__TABLE_NAME:
          Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableName"

  # Strategy configuration now packaged with code; env overrides optional

  # (no additional Globals keys)

Resources:

  # ========== AGGREGATION SESSIONS TABLE (MULTI-NODE SCALING) ==========
  # DynamoDB Table for tracking multi-node strategy aggregation sessions
  AggregationSessionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-aggregation-sessions"
        - !Sub "alchemiser-${Stage}-aggregation-sessions"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: aggregation-sessions

  # ========== EXECUTION RUNS TABLE (PER-TRADE SCALING) ==========
  # DynamoDB Table for tracking per-trade execution run state
  # Follows same pattern as AggregationSessionsTable for Strategy multi-node
  ExecutionRunsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-execution-runs"
        - !Sub "alchemiser-${Stage}-execution-runs"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: execution-runs

  # ========== REBALANCE PLAN TABLE (AUDITABILITY) ==========
  # DynamoDB Table for persisting RebalancePlan documents with 90-day TTL
  # Enables "why didn't we trade X?" queries beyond EventBridge's 24-hour retention
  RebalancePlanTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-rebalance-plans"
        - !Sub "alchemiser-${Stage}-rebalance-plans"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
        - AttributeName: GSI1PK
          AttributeType: S
        - AttributeName: GSI1SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      GlobalSecondaryIndexes:
        # GSI1: Query by correlation_id for tracing workflow decisions
        - IndexName: GSI1-CorrelationIndex
          KeySchema:
            - AttributeName: GSI1PK
              KeyType: HASH
            - AttributeName: GSI1SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: rebalance-plans

  # ========== HEDGE POSITIONS TABLE (OPTIONS HEDGING) ==========
  # DynamoDB table for active hedge positions with lifecycle tracking
  # Single-table design with GSI for roll management queries
  HedgePositionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-hedge-positions"
        - !Sub "alchemiser-${Stage}-hedge-positions"
      BillingMode: PAY_PER_REQUEST

      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
        - AttributeName: GSI1PK
          AttributeType: S
        - AttributeName: GSI1SK
          AttributeType: S

      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE

      GlobalSecondaryIndexes:
        # GSI1: Query by underlying symbol and expiration for roll management
        - IndexName: GSI1-UnderlyingExpirationIndex
          KeySchema:
            - AttributeName: GSI1PK
              KeyType: HASH
            - AttributeName: GSI1SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL

      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true

      SSESpecification:
        SSEEnabled: true

      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: hedge-positions

  # ========== HEDGE HISTORY TABLE (OPTIONS HEDGING AUDIT TRAIL) ==========
  # DynamoDB table for tracking all hedge actions for audit and compliance
  # Records HEDGE_OPENED, HEDGE_ROLLED, HEDGE_CLOSED, etc. actions
  HedgeHistoryTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-hedge-history"
        - !Sub "alchemiser-${Stage}-hedge-history"
      BillingMode: PAY_PER_REQUEST

      AttributeDefinitions:
        - AttributeName: account_id
          AttributeType: S
        - AttributeName: timestamp_action
          AttributeType: S

      KeySchema:
        - AttributeName: account_id
          KeyType: HASH
        - AttributeName: timestamp_action
          KeyType: RANGE

      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true

      SSESpecification:
        SSEEnabled: true

      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: hedge-history

  HedgeKillSwitchTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-hedge-kill-switch"
        - !Sub "alchemiser-${Stage}-hedge-kill-switch"
      BillingMode: PAY_PER_REQUEST

      AttributeDefinitions:
        - AttributeName: switch_id
          AttributeType: S

      KeySchema:
        - AttributeName: switch_id
          KeyType: HASH

      SSESpecification:
        SSEEnabled: true

      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: hedge-kill-switch

  # ========== IV HISTORY TABLE (OPTIONS HEDGING IV PERCENTILE) ==========
  # DynamoDB table for storing daily ATM IV snapshots for 252-day rolling percentile
  IVHistoryTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-iv-history"
        - !Sub "alchemiser-${Stage}-iv-history"
      BillingMode: PAY_PER_REQUEST

      AttributeDefinitions:
        - AttributeName: underlying_symbol
          AttributeType: S
        - AttributeName: record_date
          AttributeType: S

      KeySchema:
        - AttributeName: underlying_symbol
          KeyType: HASH
        - AttributeName: record_date
          KeyType: RANGE

      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true

      SSESpecification:
        SSEEnabled: true

      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: iv-history

  # ========== GROUP HISTORICAL SELECTIONS TABLE (PORTFOLIO SCORING) ==========
  # DynamoDB table for caching daily group evaluations for filter scoring
  # Used by portfolio.py to compute accurate historical returns for groups
  GroupHistoricalSelectionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-group-history"
        - !Sub "alchemiser-${Stage}-group-history"
      BillingMode: PAY_PER_REQUEST

      AttributeDefinitions:
        - AttributeName: group_id
          AttributeType: S
        - AttributeName: record_date
          AttributeType: S

      KeySchema:
        - AttributeName: group_id
          KeyType: HASH
        - AttributeName: record_date
          KeyType: RANGE

      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true

      SSESpecification:
        SSEEnabled: true

      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: group-history

  # ========== LAMBDA LAYERS & EVENT BUS ==========
  # Layers and EventBus are now in template-shared.yaml (Shared Infrastructure Stack).
  # Referenced via Fn::ImportValue using the SharedStackName parameter.

  # ============================================================================
  # MICROSERVICES ARCHITECTURE
  # ============================================================================

  # SQS Queue for reliable trade execution with DLQ
  ExecutionQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-queue"
        - !Sub "alchemiser-${Stage}-execution-queue"
      VisibilityTimeout: 900  # 15 mins for execution
      MessageRetentionPeriod: 345600  # 4 days
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ExecutionDLQ.Arn
        maxReceiveCount: 3

  ExecutionDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-dlq"
        - !Sub "alchemiser-${Stage}-execution-dlq"
      MessageRetentionPeriod: 1209600  # 14 days

  # SQS FIFO Queue for parallel per-trade execution with exactly-once processing
  # FIFO queue with perMessageGroupId throughput enables parallel Lambda invocations
  # MessageGroupId=symbol allows parallel execution across different symbols
  # MessageDeduplicationId=trade_id prevents duplicate execution (fixes Dec 19 incident)
  # SELLâ†’BUY ordering is controlled via two-phase enqueue in Portfolio Lambda
  ExecutionFifoQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution.fifo"
        - !Sub "alchemiser-${Stage}-execution.fifo"
      FifoQueue: true
      ContentBasedDeduplication: false  # Use explicit MessageDeduplicationId
      DeduplicationScope: messageGroup  # Dedup only within same symbol
      FifoThroughputLimit: perMessageGroupId  # High throughput: parallel across symbols
      VisibilityTimeout: 900  # 15 mins for execution
      MessageRetentionPeriod: 345600  # 4 days
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ExecutionFifoDLQ.Arn
        maxReceiveCount: 3

  ExecutionFifoDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-dlq.fifo"
        - !Sub "alchemiser-${Stage}-execution-dlq.fifo"
      FifoQueue: true
      MessageRetentionPeriod: 1209600  # 14 days

  # ========== HEDGE EXECUTION QUEUE (OPTIONS HEDGING) ==========
  # SQS Queue for reliable hedge order execution with DLQ
  HedgeExecutionQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-hedge-execution-queue"
        - !Sub "alchemiser-${Stage}-hedge-execution-queue"
      VisibilityTimeout: 900  # 15 mins for execution
      MessageRetentionPeriod: 345600  # 4 days
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt HedgeExecutionDLQ.Arn
        maxReceiveCount: 3

  HedgeExecutionDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-hedge-execution-dlq"
        - !Sub "alchemiser-${Stage}-hedge-execution-dlq"
      MessageRetentionPeriod: 1209600  # 14 days

  # ========== CLOUDWATCH ALARMS ==========
  # All alarms publish to default EventBridge bus (no AlarmActions needed)
  # Notifications Lambda handles CloudWatch Alarm State Change events via SES
  DLQMessageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-dlq-messages"
        - !Sub "alchemiser-${Stage}-dlq-messages"
      AlarmDescription: "Alert when messages land in the execution DLQ after 3 failed attempts"
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: QueueName
          Value: !GetAtt ExecutionDLQ.QueueName
      # AlarmActions removed - alarms automatically publish to default EventBridge bus
      # Notifications Lambda handles CloudWatch Alarm State Change events
      TreatMissingData: notBreaching

  # CloudWatch Alarm for parallel execution DLQ messages (per-trade execution failures)
  FifoDLQMessageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-parallel-dlq-messages"
        - !Sub "alchemiser-${Stage}-parallel-dlq-messages"
      AlarmDescription: "Alert when per-trade execution messages hit parallel DLQ after 3 retries"
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: QueueName
          Value: !GetAtt ExecutionFifoDLQ.QueueName
      TreatMissingData: notBreaching

  # CloudWatch Alarm for stuck execution runs (RUNNING > 30 mins)
  # Detects orphaned runs where trades never completed
  StuckRunsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-stuck-execution-runs"
        - !Sub "alchemiser-${Stage}-stuck-execution-runs"
      AlarmDescription: "Alert when execution runs are stuck in RUNNING state for >30 minutes"
      MetricName: StuckRuns
      Namespace: Alchemiser/Execution
      Statistic: Maximum
      Period: 300  # 5 minutes
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: TableName
          Value: !Ref ExecutionRunsTable
      TreatMissingData: notBreaching

  # CloudWatch Alarm for stuck aggregation sessions (PENDING > 30 mins)
  # Detects scenarios where strategy workers fail silently (e.g., async invoke dropped)
  # and the aggregation session never completes
  StuckAggregationSessionsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-stuck-aggregation-sessions"
        - !Sub "alchemiser-${Stage}-stuck-aggregation-sessions"
      AlarmDescription: "Alert when aggregation sessions stuck in PENDING state >30 mins (workers may have failed)"
      MetricName: StuckAggregationSessions
      Namespace: Alchemiser/Aggregation
      Statistic: Maximum
      Period: 300  # 5 minutes
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: TableName
          Value: !Ref AggregationSessionsTable
      TreatMissingData: notBreaching

  # ========== LAMBDA ERROR ALARMS ==========
  # These alarms catch Lambda-level failures that bypass application error handling:
  # - Timeouts (Lambda runtime terminates before try/except can catch)
  # - Out of memory
  # - Runtime crashes
  # - Unhandled exceptions that escape the handler

  # Strategy Orchestrator errors - critical: if this fails, no workers start
  StrategyOrchestratorErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-orchestrator-errors"
        - !Sub "alchemiser-${Stage}-orchestrator-errors"
      AlarmDescription: "Alert when Strategy Orchestrator Lambda has errors (timeouts, crashes)"
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref StrategyOrchestratorFunction
      TreatMissingData: notBreaching

  # Strategy Worker errors - catches timeout/crash when WorkflowFailed can't be published
  StrategyWorkerErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-worker-errors"
        - !Sub "alchemiser-${Stage}-strategy-worker-errors"
      AlarmDescription: "Alert when Strategy Worker Lambda has errors (timeouts, crashes)"
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref StrategyFunction
      TreatMissingData: notBreaching

  # Strategy Aggregator errors - catches stalled aggregation scenarios
  StrategyAggregatorErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-aggregator-errors"
        - !Sub "alchemiser-${Stage}-aggregator-errors"
      AlarmDescription: "Alert when Strategy Aggregator Lambda has errors"
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref StrategyAggregatorFunction
      TreatMissingData: notBreaching

  # Portfolio Lambda errors - catches failures in rebalance planning
  PortfolioErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-portfolio-errors"
        - !Sub "alchemiser-${Stage}-portfolio-errors"
      AlarmDescription: "Alert when Portfolio Lambda has errors"
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref PortfolioFunction
      TreatMissingData: notBreaching

  # Notifications Lambda errors - CRITICAL: if this fails, no one knows
  # This alarm publishes to default EventBridge bus, creating a feedback loop risk
  # However, since we filter by ALARM state only, recovery won't re-trigger
  NotificationsErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-notifications-errors"
        - !Sub "alchemiser-${Stage}-notifications-errors"
      AlarmDescription: "CRITICAL: Alert when Notifications Lambda fails (notifications won't be sent)"
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300  # 5 minutes - give some buffer for transient issues
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref NotificationsFunction
      TreatMissingData: notBreaching

  # Note: ExecutionQueuePolicy removed - EventBridge no longer routes to SQS.
  # Portfolio handler sends TradeMessage objects directly to SQS via SDK.

  # EventBridge Rules for event routing
  SignalGeneratedRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-signal-generated"
        - !Sub "alchemiser-${Stage}-signal-generated"
      EventBusName:
        Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
      EventPattern:
        source:
          - alchemiser.strategy
        detail-type:
          - SignalGenerated
      Targets:
        - Id: PortfolioTarget
          Arn: !GetAtt PortfolioFunction.Arn

  SignalGeneratedPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PortfolioFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt SignalGeneratedRule.Arn

  # ========== EVENTBRIDGE PERMISSIONS FOR LAMBDAS ==========
  # SAM's Events: property creates the EventBridge rule but NOT the Lambda permission.
  # These permissions grant EventBridge service permission to invoke the Lambdas.
  # Without these, EventBridge silently drops events after matching the rule.

  # Permission for TradeAggregator to be invoked by EventBridge on TradeExecuted events
  TradeAggregatorEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TradeAggregatorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub
        - "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${EventBusName}/*"
        - EventBusName:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"

  # Permission for Notifications Lambda to be invoked by EventBridge
  # Allows both AllTradesCompleted (from TradeAggregator) and WorkflowFailed (from any Lambda)
  NotificationsEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref NotificationsFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub
        - "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${EventBusName}/*"
        - EventBusName:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"

  # Permission for StrategyAggregator Lambda to be invoked by EventBridge on PartialSignalGenerated events
  StrategyAggregatorEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref StrategyAggregatorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub
        - "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${EventBusName}/*"
        - EventBusName:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"

  # Permission for Metrics Lambda to be invoked by EventBridge on TradeExecuted events
  MetricsEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref MetricsFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub
        - "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${EventBusName}/*"
        - EventBusName:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"

  # Note: RebalancePlannedRule removed - Portfolio handler sends TradeMessage
  # objects directly to SQS. The RebalancePlanned event published to EventBridge
  # is for observability only (CloudWatch Logs Insights queries).

  # Strategy Worker Lambda - Executes strategy DSL files (invoked by orchestrator or directly)
  StrategyFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-worker"
        - !Sub "alchemiser-${Stage}-strategy-worker"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/strategy_worker/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt StrategyExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-StrategyLayerArn"
      Timeout: 900  # Max timeout for on-demand data fetching
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          MARKET_DATA_BUCKET:
            Fn::ImportValue: !Sub "${SharedStackName}-MarketDataBucketName"
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
          TRADE_LEDGER__TABLE_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableName"
          # On-demand data fetching: sync refresh invokes Data Lambda when S3 cache is empty
          DATA_FUNCTION_NAME:
            Fn::ImportValue: !Sub "${DataStackName}-DataFunctionName"
          STAGE: !Ref Stage
          # Sync refresh timeout: max wait for Data Lambda to fetch missing data (5 minutes)
          SYNC_REFRESH_TIMEOUT_SECONDS: "300"
          # Enable live bar injection - appends today's current price to historical data
          # This allows indicators (e.g., 200-day SMA) to use the most recent price

    Metadata:
      BuildMethod: python3.12

  # Lambda Destinations for StrategyFunction async invocation failures
  # When StrategyOrchestratorFunction invokes workers asynchronously, failures
  # (throttling, quota, timeouts, unhandled exceptions) are routed to EventBridge
  # where WorkflowFailed rule triggers NotificationsFunction
  # Note: Lambda Destinations automatically grants the Lambda service permission
  # to publish to EventBridge - no additional IAM policy needed.
  StrategyFunctionEventInvokeConfig:
    Type: AWS::Lambda::EventInvokeConfig
    Properties:
      FunctionName: !Ref StrategyFunction
      Qualifier: $LATEST
      MaximumRetryAttempts: 2  # AWS default for async, explicit for clarity
      DestinationConfig:
        OnFailure:
          Destination:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"

  StrategyExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: &lambda-assume-role
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns: &lambda-basic-execution

        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
                  - !Sub
                    - "${TableArn}/index/*"
                    - TableArn:
                        Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
              # S3 permissions for per-stage market data bucket (read-only)
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-MarketDataBucketArn"
                  - !Sub
                    - "${BucketArn}/*"
                    - BucketArn:
                        Fn::ImportValue: !Sub "${SharedStackName}-MarketDataBucketArn"
              # Lambda invoke permission for sync refresh (on-demand data fetching)
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - Fn::ImportValue: !Sub "${DataStackName}-DataFunctionArn"

  # ========== MULTI-NODE STRATEGY SCALING (Orchestrator + Aggregator) ==========
  # These Lambdas enable horizontal scaling of strategy execution by running
  # each DSL file in a separate Lambda invocation and aggregating the results.

  # Strategy Orchestrator Lambda - Entry point that dispatches parallel strategy execution
  StrategyOrchestratorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-orchestrator"
        - !Sub "alchemiser-${Stage}-strategy-orchestrator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/strategy_orchestrator/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt StrategyOrchestratorExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-NotificationsLayerArn"
      Timeout: 60  # Orchestrator just dispatches, doesn't run strategies
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          AGGREGATION_TABLE_NAME: !Ref AggregationSessionsTable
          STRATEGY_FUNCTION_NAME: !Ref StrategyFunction
          AGGREGATION_TIMEOUT_SECONDS: "600"
    Metadata:
      BuildMethod: python3.12

  StrategyOrchestratorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: StrategyOrchestratorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt AggregationSessionsTable.Arn
              # Permission to invoke Strategy Lambda for each file
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                  - lambda:InvokeAsync
                Resource:
                  - !GetAtt StrategyFunction.Arn

  # Signal Aggregator Lambda - Aggregates partial strategy signals into consolidated portfolio
  StrategyAggregatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-signal-aggregator"
        - !Sub "alchemiser-${Stage}-signal-aggregator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/strategy_aggregator/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt StrategyAggregatorExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-NotificationsLayerArn"
      Timeout: 60  # Aggregation should be fast
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          AGGREGATION_TABLE_NAME: !Ref AggregationSessionsTable
          ALLOCATION_TOLERANCE: "0.01"
      Events:
        PartialSignalEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName:
              Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
            Pattern:
              source:
                - "alchemiser.strategy"
              detail-type:
                - "PartialSignalGenerated"
    Metadata:
      BuildMethod: python3.12

  StrategyAggregatorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: StrategyAggregatorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt AggregationSessionsTable.Arn
              # CloudWatch permissions for stuck session metrics
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: "*"

  # ========== END MULTI-NODE STRATEGY SCALING ==========

  # Portfolio Lambda - Rebalance planning microservice
  PortfolioFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-portfolio"
        - !Sub "alchemiser-${Stage}-portfolio"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/portfolio/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt PortfolioExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-PortfolioLayerArn"
      Timeout: 900  # Max timeout for comprehensive processing
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
          TRADE_LEDGER__TABLE_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableName"
          # Rebalance plan persistence for auditability
          REBALANCE_PLAN__TABLE_NAME: !Ref RebalancePlanTable
          # Per-trade execution configuration
          EXECUTION_FIFO_QUEUE_URL: !Ref ExecutionFifoQueue
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
    Metadata:
      BuildMethod: python3.12

  PortfolioExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: PortfolioPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
                  - !Sub
                    - "${TableArn}/index/*"
                    - TableArn:
                        Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
              # Per-trade parallel execution: SQS Standard queue access (named *Fifo for AWS compatibility)
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:GetQueueAttributes
                Resource:
                  - !GetAtt ExecutionFifoQueue.Arn
              # Per-trade execution: Execution runs table access
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn
              # Rebalance plan persistence for auditability
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt RebalancePlanTable.Arn
                  - !Sub "${RebalancePlanTable.Arn}/index/*"

  # Execution Lambda - Trade execution microservice (triggered via SQS)
  ExecutionFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution"
        - !Sub "alchemiser-${Stage}-execution"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/execution/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt ExecutionExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-ExecutionLayerArn"
      Timeout: 600
      MemorySize: 1024
      # Concurrency limited to 10 for Alpaca trading API rate limits (200 calls/min)
      # WebSocket handles order status updates, so each trade only makes ~1-2 REST calls
      # 10 concurrent = ~2-4 calls/sec (well under 3.33/sec limit)
      ReservedConcurrentExecutions: 10
      # WebSocket connections are cleaned up after each execution via cleanup_all_instances()
      Environment:
        Variables:
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
          TRADE_LEDGER__TABLE_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableName"
          # Per-trade execution configuration
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
          # Queue URL for triggering BUY phase after SELL phase completes
          EXECUTION_FIFO_QUEUE_URL: !Ref ExecutionFifoQueue
      Events:
        ExecutionQueue:
          Type: SQS
          Properties:
            Queue: !GetAtt ExecutionQueue.Arn
            BatchSize: 1
            FunctionResponseTypes:
              - ReportBatchItemFailures
        # Per-trade parallel execution: Standard queue (resource named *Fifo for AWS compatibility)
        ExecutionFifoQueue:
          Type: SQS
          Properties:
            Queue: !GetAtt ExecutionFifoQueue.Arn
            BatchSize: 1
            FunctionResponseTypes:
              - ReportBatchItemFailures
    Metadata:
      BuildMethod: python3.12

  ExecutionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: ExecutionPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sqs:SendMessage  # For triggering BUY phase after SELL phase completes
                Resource:
                  - !GetAtt ExecutionQueue.Arn
                  - !GetAtt ExecutionFifoQueue.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:BatchWriteItem
                  - dynamodb:UpdateItem
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
                  - !Sub
                    - "${TableArn}/index/*"
                    - TableArn:
                        Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
              # Per-trade execution: Execution runs table access
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn

  # ========== TRADE AGGREGATOR LAMBDA ==========
  # Aggregates TradeExecuted events and emits single AllTradesCompleted event
  # This eliminates race conditions in notifications by ensuring only one notification per run
  TradeAggregatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-trade-aggregator"
        - !Sub "alchemiser-${Stage}-trade-aggregator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/trade_aggregator/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt TradeAggregatorExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-NotificationsLayerArn"
      Timeout: 60  # Aggregation should be fast
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
          ENVIRONMENT: !Ref Stage
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
      Events:
        TradeExecutedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName:
              Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
            Pattern:
              source:
                - "alchemiser.execution"
              detail-type:
                - "TradeExecuted"
    Metadata:
      BuildMethod: python3.12

  TradeAggregatorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: TradeAggregatorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn

  # ========== NOTIFICATIONS LAMBDA ==========
  # Consumes TradeExecuted and WorkflowFailed events and sends email notifications
  NotificationsFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-notifications"
        - !Sub "alchemiser-${Stage}-notifications"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/notifications/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt NotificationsExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-NotificationsLayerArn"
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          PERFORMANCE_REPORTS_BUCKET:
            Fn::ImportValue: !Sub "${SharedStackName}-PerformanceReportsBucketName"
          TRADE_LEDGER__TABLE_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableName"
          # Stack name for CloudWatch Logs URL construction (matches Lambda naming pattern)
          STACK_NAME: !If
            - UseStackNameForResources
            - !Ref StackName
            - !Sub "alchemiser-${Stage}"
          # SES Configuration
          SES_FROM_ADDRESS: noreply@mail.octarine.capital
          SES_FROM_NAME: "Octarine Capital"
          SES_REPLY_TO_ADDRESS: noreply@mail.octarine.capital
          SES_REGION: !Ref AWS::Region
          # Notification recipients - success emails go to NOTIFICATION_EMAIL, failures go to FAILURE_NOTIFICATION_EMAIL
          NOTIFICATION_EMAIL: !If
            - HasNotificationEmail
            - !Ref NotificationEmail
            - "notifications@rwxt.org"
          FAILURE_NOTIFICATION_EMAIL: !If
            - HasFailureNotificationEmail
            - !Ref FailureNotificationEmail
            - "josh@rwxt.org"
          # Safety: non-prod environments must explicitly enable real emails
          ALLOW_REAL_EMAILS: !If [ IsProduction, "true", "false" ]
      Events:
        # AllTradesCompleted from TradeAggregator (one event per run, no racing)
        AllTradesCompletedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName:
              Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
            Pattern:
              source:
                - "alchemiser.trade_aggregator"
              detail-type:
                - "AllTradesCompleted"
        # Route WorkflowFailed from ANY alchemiser source to notifications
        # Each Lambda (strategy, portfolio, execution) publishes WorkflowFailed with its own source
        WorkflowFailedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName:
              Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
            Pattern:
              source:
                - prefix: "alchemiser."
              detail-type:
                - "WorkflowFailed"
        # DataLakeUpdateCompleted from Data Lambda (market data refresh success)
        DataLakeUpdateCompletedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName:
              Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
            Pattern:
              source:
                - "alchemiser.data"
              detail-type:
                - "DataLakeUpdateCompleted"
        # ScheduleCreated from Schedule Manager (schedule set, early close, or holiday skip)
        ScheduleCreatedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName:
              Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
            Pattern:
              source:
                - "alchemiser.coordinator"
              detail-type:
                - "ScheduleCreated"
        # Lambda async invocation failures from Lambda Destinations
        # Catches failures when StrategyOrchestratorFunction invokes StrategyFunction async
        # and all retries are exhausted (throttling, quota, timeout, crash)
        LambdaAsyncFailureEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName:
              Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
            Pattern:
              source:
                - "lambda"
              detail-type:
                - "Lambda Function Invocation Result - Failure"
        # CloudWatch Alarm State Changes - routes DLQ alerts, stuck runs, Lambda errors
        # through unified SES notification channel (replaces deprecated SNS topic)
        CloudWatchAlarmEvent:
          Type: EventBridgeRule
          Properties:
            # CloudWatch alarms publish to the default EventBridge bus
            Pattern:
              source:
                - "aws.cloudwatch"
              detail-type:
                - "CloudWatch Alarm State Change"
              detail:
                alarmName:
                  - prefix: "alchemiser-"
                state:
                  value:
                    - "ALARM"
    Metadata:
      BuildMethod: python3.12
      # BuildProperties removed - SAM auto-includes everything in CodeUri

  NotificationsExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: NotificationsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:GetItem
                  - dynamodb:Scan
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
                  - !Sub
                    - "${TableArn}/index/*"
                    - TableArn:
                        Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  - !Sub
                    - "${BucketArn}/*"
                    - BucketArn:
                        Fn::ImportValue: !Sub "${SharedStackName}-PerformanceReportsBucketArn"
              # SES permissions for email sending
              - Effect: Allow
                Action:
                  - ses:SendEmail
                  - ses:SendRawEmail
                Resource: "*"

  # ========== METRICS LAMBDA (PRODUCTION ONLY) ==========
  # Publishes per-strategy realized P&L metrics to CloudWatch
  MetricsFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "alchemiser-${Stage}-metrics"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/metrics/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt MetricsExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-NotificationsLayerArn"
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          TRADE_LEDGER__TABLE_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableName"
          STAGE: !Ref Stage
      Events:
        TradeExecutedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName:
              Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
            Pattern:
              source:
                - "alchemiser.execution"
              detail-type:
                - "TradeExecuted"
    Metadata:
      BuildMethod: python3.12

  MetricsExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: MetricsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:GetItem
                  - dynamodb:Scan
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
                  - !Sub
                    - "${TableArn}/index/*"
                    - TableArn:
                        Fn::ImportValue: !Sub "${SharedStackName}-TradeLedgerTableArn"
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: "*"

  # ========== HEDGE EVALUATOR LAMBDA (OPTIONS HEDGING) ==========
  # Triggered by RebalancePlanned to evaluate hedge requirements
  # Calculates sector exposure, sizes hedges, publishes HedgeEvaluationCompleted
  HedgeEvaluatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-hedge-evaluator"
        - !Sub "alchemiser-${Stage}-hedge-evaluator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/hedge_evaluator/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt HedgeEvaluatorExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-PortfolioLayerArn"
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          # Feature flag: Set to 'true' to enable options hedging (default: false for safety)
          OPTIONS_HEDGING_ENABLED: !If [ IsProduction, "false", "true" ]
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          HEDGE_EXECUTION_QUEUE_URL: !Ref HedgeExecutionQueue
          HEDGE_POSITIONS_TABLE_NAME: !Ref HedgePositionsTable
          HEDGE_HISTORY_TABLE_NAME: !Ref HedgeHistoryTable
          HEDGE_KILL_SWITCH_TABLE: !Ref HedgeKillSwitchTable
          IV_HISTORY_TABLE_NAME: !Ref IVHistoryTable
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          # Note: VIX-adaptive budget rates are defined in hedge_config.py (TAIL_HEDGE_TEMPLATE).
          # VIX value is fetched real-time from VIXY ETF proxy (VIXY price * 10 â‰ˆ VIX index).
          # Environment variables below are reserved for future runtime override capability.
          # Currently unused - the code reads from constants; uncomment to enable env-based config.
          # HEDGE_BUDGET_VIX_LOW: "0.008"
          # HEDGE_BUDGET_VIX_MID: "0.005"
          # HEDGE_BUDGET_VIX_HIGH: "0.003"
    Metadata:
      BuildMethod: python3.12

  HedgeEvaluatorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: HedgeEvaluatorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource:
                  - !GetAtt HedgeExecutionQueue.Arn
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt HedgePositionsTable.Arn
                  - !Sub "${HedgePositionsTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource:
                  - !GetAtt HedgeHistoryTable.Arn
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt HedgeKillSwitchTable.Arn
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt IVHistoryTable.Arn

  # ==========================================================================
  # BREAKING ARCHITECTURAL CHANGE (PPO/Signal Indicators PR):
  # HedgeEvaluator is now triggered by AllTradesCompleted (from TradeAggregator)
  # instead of the previous RebalancePlanned event.
  #
  # Previous behavior: Hedge evaluation ran after portfolio planning, before trades.
  # New behavior: Hedge evaluation runs after ALL trades complete successfully.
  #
  # Rationale: Hedging actual positions (post-execution) is more accurate than
  # hedging planned positions that may not fully execute. This also decouples
  # hedging from the main equity workflow timing.
  #
  # Migration: Any integrations expecting HedgeEvaluationCompleted to occur
  # before trade execution must be updated. See handle_all_trades_completed()
  # in hedge_evaluation_handler.py.
  # ==========================================================================
  AllTradesCompletedToHedgeRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-trades-completed-to-hedge"
        - !Sub "alchemiser-${Stage}-trades-completed-to-hedge"
      EventBusName:
        Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
      EventPattern:
        source:
          - alchemiser.trade_aggregator
        detail-type:
          - AllTradesCompleted
      Targets:
        - Id: HedgeEvaluatorTarget
          Arn: !GetAtt HedgeEvaluatorFunction.Arn

  AllTradesCompletedToHedgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref HedgeEvaluatorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt AllTradesCompletedToHedgeRule.Arn

  # ========== HEDGE EXECUTOR LAMBDA (OPTIONS HEDGING) ==========
  # Triggered by SQS queue to execute hedge orders via Alpaca Options API
  HedgeExecutorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-hedge-executor"
        - !Sub "alchemiser-${Stage}-hedge-executor"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/hedge_executor/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt HedgeExecutorExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-ExecutionLayerArn"
      Timeout: 600
      MemorySize: 1024
      ReservedConcurrentExecutions: 3  # Conservative for options API limits
      Environment:
        Variables:
          # Feature flag: Set to 'true' to enable options hedging (default: false for safety)
          OPTIONS_HEDGING_ENABLED: !If [ IsProduction, "false", "true" ]
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          HEDGE_POSITIONS_TABLE_NAME: !Ref HedgePositionsTable
          HEDGE_HISTORY_TABLE_NAME: !Ref HedgeHistoryTable
          HEDGE_KILL_SWITCH_TABLE: !Ref HedgeKillSwitchTable
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
      Events:
        HedgeExecutionQueue:
          Type: SQS
          Properties:
            Queue: !GetAtt HedgeExecutionQueue.Arn
            BatchSize: 1
            FunctionResponseTypes:
              - ReportBatchItemFailures
    Metadata:
      BuildMethod: python3.12

  HedgeExecutorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: HedgeExecutorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                Resource:
                  - !GetAtt HedgeExecutionQueue.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt HedgePositionsTable.Arn
                  - !Sub "${HedgePositionsTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource:
                  - !GetAtt HedgeHistoryTable.Arn
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt HedgeKillSwitchTable.Arn

  # ========== HEDGE ROLL MANAGER LAMBDA (OPTIONS HEDGING) ==========
  # Scheduled daily to scan expiring hedges and trigger rolls
  HedgeRollManagerFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-hedge-roll-manager"
        - !Sub "alchemiser-${Stage}-hedge-roll-manager"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/hedge_roll_manager/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt HedgeRollManagerExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-PortfolioLayerArn"
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          # Feature flag: Set to 'true' to enable options hedging (default: false for safety)
          OPTIONS_HEDGING_ENABLED: !If [ IsProduction, "false", "true" ]
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          HEDGE_EXECUTION_QUEUE_URL: !Ref HedgeExecutionQueue
          HEDGE_POSITIONS_TABLE_NAME: !Ref HedgePositionsTable
          HEDGE_HISTORY_TABLE_NAME: !Ref HedgeHistoryTable
      Events:
        # Daily schedule: ~3:45 PM Eastern Time (after equity rebalance at 3:30 PM)
        # TIMEZONE NOTE: This schedule uses 19:45 UTC which equals:
        #   - 3:45 PM EDT (during daylight saving time, Mar-Nov)
        #   - 2:45 PM EST (during standard time, Nov-Mar)
        # AWS EventBridge does not natively support US timezone rules.
        # Acceptable for roll checks as 1-hour variance has minimal impact.
        DailyRollCheck:
          Type: Schedule
          Properties:
            Schedule: "cron(45 19 ? * MON-FRI *)"
            Description: "Daily hedge roll check (~3:45 PM ET, see comment for timezone note)"
    Metadata:
      BuildMethod: python3.12

  HedgeRollManagerExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: HedgeRollManagerPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource:
                  - !GetAtt HedgeExecutionQueue.Arn
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt HedgePositionsTable.Arn
                  - !Sub "${HedgePositionsTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource:
                  - !GetAtt HedgeHistoryTable.Arn

  # DataFunction, DataExecutionRole, DataEventBridgePermission moved to data stack (template-data.yaml)
  # Referenced via Fn::ImportValue using DataStackName parameter.

  # REMOVED: Production fallback schedule (was at 3:50 PM ET Mon-Fri)
  # The fallback schedule was causing double runs when the dynamic schedule succeeded.
  # All environments (dev/staging/prod) now rely solely on the Schedule Manager for dynamic scheduling.
  # The Schedule Manager creates one-time schedules at 15 minutes before market close (accounting for early close days).
  # If the Schedule Manager fails, we will be notified through normal WorkflowFailed event channels.
  # Historical note: The fallback was intended as a "safety net" but added unnecessary complexity.

  # StrategySchedule resource removed - see issue "Double run bug" for details.

  StrategySchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: &scheduler-assume-role
        Statement:
          - Effect: Allow
            Principal:
              Service: scheduler.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeStrategy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt StrategyFunction.Arn
                  - !GetAtt StrategyOrchestratorFunction.Arn

  # ========== SCHEDULE MANAGER (Dynamic Early Close Handling) ==========
  # This Lambda runs early each trading day to create a one-time schedule
  # for the Strategy Orchestrator, accounting for early close days.

  ScheduleManagerFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-schedule-manager"
        - !Sub "alchemiser-${Stage}-schedule-manager"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/schedule_manager/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt ScheduleManagerExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-NotificationsLayerArn"
      Timeout: 60
      MemorySize: 256
      Environment:
        Variables:
          ORCHESTRATOR_FUNCTION_ARN: !GetAtt StrategyOrchestratorFunction.Arn
          SCHEDULER_ROLE_ARN: !GetAtt StrategySchedulerRole.Arn
          SCHEDULE_GROUP_NAME: "default"
          MINUTES_BEFORE_CLOSE: "15"
          EVENT_BUS_NAME:
            Fn::ImportValue: !Sub "${SharedStackName}-EventBusName"
          # ALPACA__KEY, ALPACA__SECRET, ALPACA__ENDPOINT come from Globals
    Metadata:
      BuildMethod: python3.12

  ScheduleManagerExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: ScheduleManagerPolicy
          PolicyDocument:
            Statement:
              # Permission to create/delete EventBridge Scheduler rules
              - Effect: Allow
                Action:
                  - scheduler:CreateSchedule
                  - scheduler:DeleteSchedule
                  - scheduler:GetSchedule
                Resource:
                  - !Sub "arn:aws:scheduler:${AWS::Region}:${AWS::AccountId}:schedule/default/*-trading-execution-*"
              # Permission to pass role to scheduler
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  - !GetAtt StrategySchedulerRole.Arn
                Condition:
                  StringEquals:
                    iam:PassedToService: scheduler.amazonaws.com
              # Permission to publish events to EventBridge
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-EventBusArn"

  # Morning schedule to trigger Schedule Manager (checks calendar and sets up today's execution)
  ScheduleManagerSchedule:
    Type: AWS::Scheduler::Schedule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-schedule-manager"
        - !Sub "alchemiser-${Stage}-schedule-manager"
      Description: "Run Schedule Manager at 9:00 AM ET to set up today's trading schedule"
      ScheduleExpression: "cron(0 9 ? * MON-FRI *)"
      ScheduleExpressionTimezone: "America/New_York"
      FlexibleTimeWindow:
        Mode: "OFF"
      Target:
        Arn: !GetAtt ScheduleManagerFunction.Arn
        RoleArn: !GetAtt ScheduleManagerSchedulerRole.Arn
        Input: '{"source": "morning_schedule"}'
        RetryPolicy:
          MaximumRetryAttempts: 2

  ScheduleManagerSchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *scheduler-assume-role
      Policies:
        - PolicyName: InvokeScheduleManager
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt ScheduleManagerFunction.Arn

  # ========== GROUP CACHE LAMBDA (PORTFOLIO SCORING CACHE) ==========
  # Evaluates filterable groups daily and caches selections in DynamoDB
  # for accurate historical scoring in filter operators
  GroupCacheFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-group-cache"
        - !Sub "alchemiser-${Stage}-group-cache"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/group_cache/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt GroupCacheExecutionRole.Arn
      Layers:
        - Fn::ImportValue: !Sub "${SharedStackName}-SharedCodeLayerArn"
        - Fn::ImportValue: !Sub "${SharedStackName}-StrategyLayerArn"
      Timeout: 300
      MemorySize: 1024
      Environment:
        Variables:
          GROUP_HISTORY_TABLE: !Ref GroupHistoricalSelectionsTable
          CACHE_TTL_DAYS: "30"
          MARKET_DATA_BUCKET:
            Fn::ImportValue: !Sub "${SharedStackName}-MarketDataBucketName"
          DATA_FUNCTION_NAME:
            Fn::ImportValue: !Sub "${DataStackName}-DataFunctionName"
          # ALPACA__KEY, ALPACA__SECRET, ALPACA__ENDPOINT come from Globals
    Metadata:
      BuildMethod: python3.12

  GroupCacheExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambda-assume-role
      ManagedPolicyArns: *lambda-basic-execution
      Policies:
        - PolicyName: GroupCachePolicy
          PolicyDocument:
            Statement:
              # Permission to write to group history table
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt GroupHistoricalSelectionsTable.Arn
              # Permission to read from market data bucket
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - Fn::ImportValue: !Sub "${SharedStackName}-MarketDataBucketArn"
                  - !Sub
                    - "${BucketArn}/*"
                    - BucketArn:
                        Fn::ImportValue: !Sub "${SharedStackName}-MarketDataBucketArn"
              # Permission to invoke data function for sync refresh
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - Fn::ImportValue: !Sub "${DataStackName}-DataFunctionArn"

  # Morning schedule to run group cache at 4:00 AM ET (before market open)
  GroupCacheSchedule:
    Type: AWS::Scheduler::Schedule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-group-cache"
        - !Sub "alchemiser-${Stage}-group-cache"
      Description: "Run Group Cache at 4:00 AM ET to update historical selections"
      ScheduleExpression: "cron(0 4 ? * MON-FRI *)"
      ScheduleExpressionTimezone: "America/New_York"
      FlexibleTimeWindow:
        Mode: "OFF"
      Target:
        Arn: !GetAtt GroupCacheFunction.Arn
        RoleArn: !GetAtt GroupCacheSchedulerRole.Arn
        Input: '{"source": "morning_schedule"}'
        RetryPolicy:
          MaximumRetryAttempts: 2

  GroupCacheSchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *scheduler-assume-role
      Policies:
        - PolicyName: InvokeGroupCache
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt GroupCacheFunction.Arn

  # DataRefreshSchedule, DataRefreshPostCloseSchedule, DataSchedulerRole moved to data stack (template-data.yaml)
  # AccountDataFunction, AccountDataExecutionRole, AccountDataSchedule, AccountDataSchedulerRole moved to data stack (template-data.yaml)

  # ============================================================================
  # END MICROSERVICES ARCHITECTURE
  # ============================================================================
  # Note: Data Lambda moved to shared infrastructure (data-template.yaml)
  # The shared Data Lambda serves all stages from alchemiser-shared-data

  # ========== STREAMLIT DASHBOARD IAM USER ==========
  # NOTE: The IAM user for the Streamlit dashboard must be created manually via AWS Console
  # because the GitHub Actions role lacks IAM user management permissions.
  # See scripts/DASHBOARD_README.md for instructions on creating the user and policy.

Outputs:
  AggregationSessionsTableName:
    Description: "DynamoDB table for multi-node strategy aggregation sessions"
    Value: !Ref AggregationSessionsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-AggregationSessionsTable"
        - !Sub "alchemiser-${Stage}-AggregationSessionsTable"

  ExecutionRunsTableName:
    Description: "DynamoDB table for per-trade execution run tracking"
    Value: !Ref ExecutionRunsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-ExecutionRunsTable"
        - !Sub "alchemiser-${Stage}-ExecutionRunsTable"

  RebalancePlanTableName:
    Description: "DynamoDB table for rebalance plan auditability (90-day TTL)"
    Value: !Ref RebalancePlanTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-RebalancePlanTable"
        - !Sub "alchemiser-${Stage}-RebalancePlanTable"

  ExecutionFifoQueueUrl:
    Description: "SQS Standard queue for parallel per-trade execution"
    Value: !Ref ExecutionFifoQueue
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-ExecutionFifoQueue"
        - !Sub "alchemiser-${Stage}-ExecutionFifoQueue"

  DeploymentStage:
    Description: "Deployed stage"
    Value: !Ref Stage
  
  StackNameUsed:
    Description: "Stack name used for resource naming"
    Value: !If [ HasStackName, !Ref StackName, !Sub "alchemiser-${Stage}" ]

  LogsInsightsURL:
    Description: "CloudWatch Logs Insights for querying logs across all Lambdas"
    Value: !Sub "https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#logsV2:logs-insights"

# yaml-language-server: $schema=https://raw.githubusercontent.com/aws/serverless-application-model/main/samtranslator/validator/sam_schema/schema.json
# yaml-language-server: disable-validation
AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: >
  The Alchemiser Quantitative Trading System

  Multi-strategy algorithmic trading engine deployed as an AWS Lambda Function

Parameters:
  Stage:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - staging
      - prod
      - ephemeral
    Description: Deployment stage (dev, staging, prod, or ephemeral)
  
  StackName:
    Type: String
    Default: ""
    Description: Optional override for stack-specific resource naming (used for ephemeral stacks)
  
  Env:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - staging
      - prod
      - ephemeral
    Description: Environment type for resource configuration
  
  ArtifactPrefix:
    Type: String
    Default: ""
    Description: S3 prefix for artifacts (used for ephemeral stack isolation)

  AlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key (used only in dev; leave blank for prod)

  AlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret (used only in dev; leave blank for prod)

  AlpacaEndpoint:
    Type: String
    Default: https://paper-api.alpaca.markets/v2
    Description: Alpaca API endpoint; defaults to paper for dev, live is used for prod

  EmailPassword:
    Type: String
    Default: ""
    NoEcho: true
    Description: Email SMTP password for dev notifications (optional)

  # Margin/Leverage configuration
  EquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: ALPACA__EQUITY_DEPLOYMENT_PCT - percentage of equity to deploy (1.0=100%, 1.10=110% with margin)

  ProdEquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: Equity deployment percentage for production (conservative default)

  # Staging-only parameters (only used when Stage=staging)
  StagingAlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key for staging (required when Stage=staging)

  StagingAlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret for staging (required when Stage=staging)

  StagingAlpacaEndpoint:
    Type: String
    Default: https://paper-api.alpaca.markets/v2
    Description: Alpaca API endpoint for staging (typically paper trading)

  StagingEmailPassword:
    Type: String
    Default: ""
    NoEcho: true
    Description: Email SMTP password for staging notifications (optional)

  StagingEquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: Equity deployment percentage for staging

  # Production-only parameters (only used when Stage=prod)
  ProdAlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key for production (required when Stage=prod)

  ProdAlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret for production (required when Stage=prod)

  ProdAlpacaEndpoint:
    Type: String
    Default: https://api.alpaca.markets
    Description: Alpaca API endpoint for production

  ProdEmailPassword:
    Type: String
    Default: ""
    NoEcho: true
    Description: Email SMTP password for production notifications (optional)

  # Shared Data Infrastructure
  SharedMarketDataBucket:
    Type: String
    Default: alchemiser-shared-market-data
    Description: Name of the shared market data S3 bucket (deployed via data-template.yaml)

  # Strategy configuration: now defined in code defaults. Override via env only if required.

Mappings:
  StageConfig:
    dev:
      TitleCase: "Dev"
    staging:
      TitleCase: "Staging"
    prod:
      TitleCase: "Production"
    ephemeral:
      TitleCase: "Ephemeral"

Conditions:
  IsDev: !Equals [ !Ref Stage, dev ]
  IsStaging: !Equals [ !Ref Stage, staging ]
  IsProduction: !Equals [ !Ref Stage, prod ]
  IsEphemeral: !Equals [ !Ref Stage, ephemeral ]
  HasStackName: !Not [ !Equals [ !Ref StackName, "" ] ]
  UseStackNameForResources: !Or [ !Condition IsEphemeral, !Condition HasStackName ]

Globals:
  Function:
    Timeout: 900 # 15 minutes - max for Lambda
    MemorySize: 512
    Environment:
      Variables:
        # Stage awareness for code-level profiles
        APP__STAGE: !If [ IsProduction, "prod", !If [ IsStaging, "staging", "dev" ] ]
        # Alpaca Configuration
        ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
        ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
        ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
        # Email Configuration
        EMAIL__SMTP_SERVER: smtp.mail.me.com
        EMAIL__SMTP_PORT: 587
        EMAIL__FROM_EMAIL: joshuamoreton1@icloud.com
        EMAIL__TO_EMAIL: notifications@rwxt.org
        EMAIL__NEUTRAL_MODE: true
        EMAIL__PASSWORD: !If [ IsProduction, !Ref ProdEmailPassword, !If [ IsStaging, !Ref StagingEmailPassword, !Ref EmailPassword ] ]
        # Strategy DSL configuration now comes from code defaults; override via env only if necessary
        # STRATEGY__DSL_FILES: '["1-KMLM.clj","2-Nuclear.clj","5-Coin.clj","6-TQQQ-FLT.clj"]'
        # STRATEGY__DSL_ALLOCATIONS: '{"1-KMLM.clj":0.4,"2-Nuclear.clj":0.25,"5-Coin.clj":0.1,"6-TQQQ-FLT.clj":0.25}'

        # Margin/Leverage configuration - controls how much of equity to deploy
        # 1.0 = 100% of equity (no margin), 1.10 = 110% (10% margin usage)
        ALPACA__EQUITY_DEPLOYMENT_PCT: !If [ IsProduction, !Ref ProdEquityDeploymentPct, !If [ IsStaging, !Ref StagingEquityDeploymentPct, !Ref EquityDeploymentPct ] ]

        # Trade ledger DynamoDB table
        TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable

  # Strategy configuration now packaged with code; env overrides optional

  # (no additional Globals keys)

Resources:
  # DynamoDB Table for trade ledger persistence
  TradeLedgerTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-trade-ledger"
        - !Sub "alchemiser-${Stage}-trade-ledger"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
        - AttributeName: GSI1PK
          AttributeType: S
        - AttributeName: GSI1SK
          AttributeType: S
        - AttributeName: GSI2PK
          AttributeType: S
        - AttributeName: GSI2SK
          AttributeType: S
        - AttributeName: GSI3PK
          AttributeType: S
        - AttributeName: GSI3SK
          AttributeType: S
        - AttributeName: GSI4PK
          AttributeType: S
        - AttributeName: GSI4SK
          AttributeType: S
        - AttributeName: GSI5PK
          AttributeType: S
        - AttributeName: GSI5SK
          AttributeType: S
        - AttributeName: GSI6PK
          AttributeType: S
        - AttributeName: GSI6SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      GlobalSecondaryIndexes:
        # GSI1: Query by correlation_id
        - IndexName: GSI1-CorrelationIndex
          KeySchema:
            - AttributeName: GSI1PK
              KeyType: HASH
            - AttributeName: GSI1SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI2: Query by symbol
        - IndexName: GSI2-SymbolIndex
          KeySchema:
            - AttributeName: GSI2PK
              KeyType: HASH
            - AttributeName: GSI2SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI3: Query by strategy
        - IndexName: GSI3-StrategyIndex
          KeySchema:
            - AttributeName: GSI3PK
              KeyType: HASH
            - AttributeName: GSI3SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI4: Query snapshots by correlation_id
        - IndexName: GSI4-CorrelationSnapshotIndex
          KeySchema:
            - AttributeName: GSI4PK
              KeyType: HASH
            - AttributeName: GSI4SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI5: Query strategy lots by strategy name (for FIFO P&L tracking)
        - IndexName: GSI5-StrategyLotsIndex
          KeySchema:
            - AttributeName: GSI5PK
              KeyType: HASH
            - AttributeName: GSI5SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI6: Query strategy lots by symbol (cross-strategy position analysis)
        - IndexName: GSI6-SymbolLotsIndex
          KeySchema:
            - AttributeName: GSI6PK
              KeyType: HASH
            - AttributeName: GSI6SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      
      SSESpecification:
        SSEEnabled: true
        # Use AWS-managed encryption (not KMS) to avoid requiring additional IAM permissions
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: trade-ledger

  # ========== AGGREGATION SESSIONS TABLE (MULTI-NODE SCALING) ==========
  # DynamoDB Table for tracking multi-node strategy aggregation sessions
  AggregationSessionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-aggregation-sessions"
        - !Sub "alchemiser-${Stage}-aggregation-sessions"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: aggregation-sessions

  # ========== EXECUTION RUNS TABLE (PER-TRADE SCALING) ==========
  # DynamoDB Table for tracking per-trade execution run state
  # Follows same pattern as AggregationSessionsTable for Strategy multi-node
  ExecutionRunsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-execution-runs"
        - !Sub "alchemiser-${Stage}-execution-runs"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: execution-runs

  # ========== REBALANCE PLAN TABLE (AUDITABILITY) ==========
  # DynamoDB Table for persisting RebalancePlan documents with 90-day TTL
  # Enables "why didn't we trade X?" queries beyond EventBridge's 24-hour retention
  RebalancePlanTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-rebalance-plans"
        - !Sub "alchemiser-${Stage}-rebalance-plans"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
        - AttributeName: GSI1PK
          AttributeType: S
        - AttributeName: GSI1SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      GlobalSecondaryIndexes:
        # GSI1: Query by correlation_id for tracing workflow decisions
        - IndexName: GSI1-CorrelationIndex
          KeySchema:
            - AttributeName: GSI1PK
              KeyType: HASH
            - AttributeName: GSI1SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: rebalance-plans

  # ========== FUNCTION-SPECIFIC LAMBDA LAYERS ==========
  # Each Lambda gets its own optimized layer with only required dependencies
  # boto3/botocore excluded from all layers - Lambda runtime provides them

  # Strategy Layer: awswrangler (pandas, numpy, pyarrow) + alpaca-py
  # Built via Makefile: downloads pre-built awswrangler, adds alpaca-py
  StrategyLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-deps"
        - !Sub "alchemiser-${Stage}-strategy-deps"
      Description: awswrangler 3.10.0 + alpaca-py (pandas, numpy, pyarrow included)
      ContentUri: layers/strategy/
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - x86_64
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: makefile

  # Portfolio Layer: alpaca-py + pydantic (no pandas/numpy)
  PortfolioLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-portfolio-deps"
        - !Sub "alchemiser-${Stage}-portfolio-deps"
      Description: Portfolio Lambda dependencies (alpaca-py, pydantic)
      ContentUri: layers/portfolio/
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # Execution Layer: alpaca-py + pydantic (no pandas/numpy)
  ExecutionLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-deps"
        - !Sub "alchemiser-${Stage}-execution-deps"
      Description: Execution Lambda dependencies (alpaca-py, pydantic)
      ContentUri: layers/execution/
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # Notifications Layer: pydantic + structlog (minimal footprint)
  NotificationsLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-notifications-deps"
        - !Sub "alchemiser-${Stage}-notifications-deps"
      Description: Notifications Lambda dependencies (pydantic, structlog)
      ContentUri: layers/notifications/
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # Data Layer: awswrangler (pandas, numpy, pyarrow) + alpaca-py
  # Built via Makefile: downloads pre-built awswrangler, adds alpaca-py
  # Total size: ~186MB unzipped (under 250MB limit)
  DataLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-data-deps"
        - !Sub "alchemiser-${Stage}-data-deps"
      Description: awswrangler 3.10.0 + alpaca-py (pandas, numpy, pyarrow included)
      ContentUri: layers/data/
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - x86_64
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: makefile

  # ============================================================================
  # MICROSERVICES ARCHITECTURE
  # ============================================================================

  # EventBridge Event Bus for async domain event communication
  AlchemiserEventBus:
    Type: AWS::Events::EventBus
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-events"
        - !Sub "alchemiser-${Stage}-events"

  # SQS Queue for reliable trade execution with DLQ
  ExecutionQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-queue"
        - !Sub "alchemiser-${Stage}-execution-queue"
      VisibilityTimeout: 900  # 15 mins for execution
      MessageRetentionPeriod: 345600  # 4 days
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ExecutionDLQ.Arn
        maxReceiveCount: 3

  ExecutionDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-dlq"
        - !Sub "alchemiser-${Stage}-execution-dlq"
      MessageRetentionPeriod: 1209600  # 14 days

  # SQS Standard Queue for parallel per-trade execution
  # Standard queue enables parallel Lambda invocations (up to ReservedConcurrentExecutions)
  # SELLâ†’BUY ordering is controlled via two-phase enqueue in Portfolio Lambda
  ExecutionFifoQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-parallel"
        - !Sub "alchemiser-${Stage}-execution-parallel"
      VisibilityTimeout: 900  # 15 mins for execution
      MessageRetentionPeriod: 345600  # 4 days
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ExecutionFifoDLQ.Arn
        maxReceiveCount: 3

  ExecutionFifoDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-parallel-dlq"
        - !Sub "alchemiser-${Stage}-execution-parallel-dlq"
      MessageRetentionPeriod: 1209600  # 14 days

  # SNS Topic for DLQ alerts (very low cost: ~$0.50/million messages)
  DLQAlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-dlq-alerts"
        - !Sub "alchemiser-${Stage}-dlq-alerts"
      DisplayName: "Alchemiser DLQ Alert"

  # Email subscription for DLQ alerts
  DLQAlertEmailSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref DLQAlertTopic
      Protocol: email
      Endpoint: notifications@rwxt.org

  # ========== PERFORMANCE REPORTS S3 BUCKET ==========
  # S3 bucket for strategy performance CSV reports with presigned URL access
  PerformanceReportsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !If
        - HasStackName
        - !Sub "${StackName}-performance-reports"
        - !Sub "alchemiser-${Stage}-reports"
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldReports
            ExpirationInDays: 30
            Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: performance-reports

  # ========== MARKET DATA S3 BUCKET ==========
  # DEPRECATED: Per-stage bucket replaced by shared bucket (alchemiser-shared-market-data)
  # Deployed via data-template.yaml - use SharedMarketDataBucket parameter instead
  # 
  # MarketDataBucket:
  #   Type: AWS::S3::Bucket
  #   Properties:
  #     BucketName: !If
  #       - HasStackName
  #       - !Sub "${StackName}-historical-market-data"
  #       - !Sub "alchemiser-${Stage}-market-data"
  #     VersioningConfiguration:
  #       Status: Enabled
  #     PublicAccessBlockConfiguration:
  #       BlockPublicAcls: true
  #       BlockPublicPolicy: true
  #       IgnorePublicAcls: true
  #       RestrictPublicBuckets: true
  #     BucketEncryption:
  #       ServerSideEncryptionConfiguration:
  #         - ServerSideEncryptionByDefault:
  #             SSEAlgorithm: AES256
  #     Tags:
  #       - Key: Environment
  #         Value: !Ref Stage
  #       - Key: Service
  #         Value: market-data

  # ========== TRADING NOTIFICATIONS SNS ==========
  # SNS Topic for trading notifications (trade results, workflow failures)
  TradingNotificationsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-trading-notifications"
        - !Sub "alchemiser-${Stage}-trading-notifications"
      DisplayName: "Alchemiser Trading Notifications"

  # Email subscription for trading notifications
  TradingNotificationsEmailSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref TradingNotificationsTopic
      Protocol: email
      Endpoint: notifications@rwxt.org

  # CloudWatch Alarm for DLQ messages (triggers when messages hit DLQ)
  DLQMessageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-dlq-messages"
        - !Sub "alchemiser-${Stage}-dlq-messages"
      AlarmDescription: "Alert when messages land in the execution DLQ after 3 failed attempts"
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: QueueName
          Value: !GetAtt ExecutionDLQ.QueueName
      AlarmActions:
        - !Ref DLQAlertTopic
      TreatMissingData: notBreaching

  # CloudWatch Alarm for parallel execution DLQ messages (per-trade execution failures)
  FifoDLQMessageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-parallel-dlq-messages"
        - !Sub "alchemiser-${Stage}-parallel-dlq-messages"
      AlarmDescription: "Alert when per-trade execution messages hit parallel DLQ after 3 retries"
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: QueueName
          Value: !GetAtt ExecutionFifoDLQ.QueueName
      AlarmActions:
        - !Ref DLQAlertTopic
      TreatMissingData: notBreaching

  # CloudWatch Alarm for stuck execution runs (RUNNING > 30 mins)
  # Detects orphaned runs where trades never completed
  StuckRunsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-stuck-execution-runs"
        - !Sub "alchemiser-${Stage}-stuck-execution-runs"
      AlarmDescription: "Alert when execution runs are stuck in RUNNING state for >30 minutes"
      MetricName: StuckRuns
      Namespace: Alchemiser/Execution
      Statistic: Maximum
      Period: 300  # 5 minutes
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: TableName
          Value: !Ref ExecutionRunsTable
      AlarmActions:
        - !Ref DLQAlertTopic
      TreatMissingData: notBreaching

  # Note: ExecutionQueuePolicy removed - EventBridge no longer routes to SQS.
  # Portfolio handler sends TradeMessage objects directly to SQS via SDK.

  # EventBridge Rules for event routing
  SignalGeneratedRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-signal-generated"
        - !Sub "alchemiser-${Stage}-signal-generated"
      EventBusName: !Ref AlchemiserEventBus
      EventPattern:
        source:
          - alchemiser.strategy
        detail-type:
          - SignalGenerated
      Targets:
        - Id: PortfolioTarget
          Arn: !GetAtt PortfolioFunction.Arn

  SignalGeneratedPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PortfolioFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt SignalGeneratedRule.Arn

  # ========== EVENTBRIDGE PERMISSIONS FOR LAMBDAS ==========
  # SAM's Events: property creates the EventBridge rule but NOT the Lambda permission.
  # These permissions grant EventBridge service permission to invoke the Lambdas.
  # Without these, EventBridge silently drops events after matching the rule.

  # Permission for TradeAggregator to be invoked by EventBridge on TradeExecuted events
  TradeAggregatorEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TradeAggregatorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AlchemiserEventBus.Name}/*"

  # Permission for Notifications Lambda to be invoked by EventBridge
  # Allows both AllTradesCompleted (from TradeAggregator) and WorkflowFailed (from any Lambda)
  NotificationsEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref NotificationsFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AlchemiserEventBus.Name}/*"

  # Permission for StrategyAggregator Lambda to be invoked by EventBridge on PartialSignalGenerated events
  StrategyAggregatorEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref StrategyAggregatorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AlchemiserEventBus.Name}/*"

  # Permission for Metrics Lambda to be invoked by EventBridge on TradeExecuted events
  MetricsEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref MetricsFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AlchemiserEventBus.Name}/*"

  # Note: RebalancePlannedRule removed - Portfolio handler sends TradeMessage
  # objects directly to SQS. The RebalancePlanned event published to EventBridge
  # is for observability only (CloudWatch Logs Insights queries).

  # Strategy Worker Lambda - Executes strategy DSL files (invoked by orchestrator or directly)
  StrategyFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-worker"
        - !Sub "alchemiser-${Stage}-strategy-worker"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.strategy_v2.lambda_handler.lambda_handler
      Role: !GetAtt StrategyExecutionRole.Arn
      Layers:
        - !Ref StrategyLayer  # awswrangler + alpaca-py (built via Makefile)
      Timeout: 900  # Max timeout for on-demand data fetching
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          MARKET_DATA_BUCKET: !Ref SharedMarketDataBucket
          ALPACA__KEY: !If [ IsDev, !Ref AlpacaKey, !Ref ProdAlpacaKey ]
          ALPACA__SECRET: !If [ IsDev, !Ref AlpacaSecret, !Ref ProdAlpacaSecret ]
          ALPACA__ENDPOINT: !If [ IsDev, !Ref AlpacaEndpoint, !Ref ProdAlpacaEndpoint ]
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # Enable live bar injection - appends today's current price to historical data
          # This allows indicators (e.g., 200-day SMA) to use the most recent price

    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  StrategyExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              # S3 permissions for shared market data bucket (read-only)
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${SharedMarketDataBucket}"
                  - !Sub "arn:aws:s3:::${SharedMarketDataBucket}/*"

  # ========== MULTI-NODE STRATEGY SCALING (Orchestrator + Aggregator) ==========
  # These Lambdas enable horizontal scaling of strategy execution by running
  # each DSL file in a separate Lambda invocation and aggregating the results.

  # Strategy Orchestrator Lambda - Entry point that dispatches parallel strategy execution
  StrategyOrchestratorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-orchestrator"
        - !Sub "alchemiser-${Stage}-strategy-orchestrator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.coordinator_v2.lambda_handler.lambda_handler
      Role: !GetAtt StrategyOrchestratorExecutionRole.Arn
      Layers:
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog)
      Timeout: 60  # Orchestrator just dispatches, doesn't run strategies
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          AGGREGATION_TABLE_NAME: !Ref AggregationSessionsTable
          STRATEGY_FUNCTION_NAME: !Ref StrategyFunction
          AGGREGATION_TIMEOUT_SECONDS: "600"
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  StrategyOrchestratorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyOrchestratorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt AggregationSessionsTable.Arn
              # Permission to invoke Strategy Lambda for each file
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                  - lambda:InvokeAsync
                Resource:
                  - !GetAtt StrategyFunction.Arn

  # Signal Aggregator Lambda - Aggregates partial strategy signals into consolidated portfolio
  StrategyAggregatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-signal-aggregator"
        - !Sub "alchemiser-${Stage}-signal-aggregator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.aggregator_v2.lambda_handler.lambda_handler
      Role: !GetAtt StrategyAggregatorExecutionRole.Arn
      Layers:
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog)
      Timeout: 60  # Aggregation should be fast
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          AGGREGATION_TABLE_NAME: !Ref AggregationSessionsTable
          ALLOCATION_TOLERANCE: "0.01"
      Events:
        PartialSignalEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.strategy"
              detail-type:
                - "PartialSignalGenerated"
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  StrategyAggregatorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyAggregatorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt AggregationSessionsTable.Arn

  # ========== END MULTI-NODE STRATEGY SCALING ==========

  # Portfolio Lambda - Rebalance planning microservice
  PortfolioFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-portfolio"
        - !Sub "alchemiser-${Stage}-portfolio"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.portfolio_v2.lambda_handler.lambda_handler
      Role: !GetAtt PortfolioExecutionRole.Arn
      Layers:
        - !Ref PortfolioLayer
      Timeout: 900  # Max timeout for comprehensive processing
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          ALPACA__KEY: !If [ IsDev, !Ref AlpacaKey, !Ref ProdAlpacaKey ]
          ALPACA__SECRET: !If [ IsDev, !Ref AlpacaSecret, !Ref ProdAlpacaSecret ]
          ALPACA__ENDPOINT: !If [ IsDev, !Ref AlpacaEndpoint, !Ref ProdAlpacaEndpoint ]
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # Rebalance plan persistence for auditability
          REBALANCE_PLAN__TABLE_NAME: !Ref RebalancePlanTable
          # Per-trade execution configuration
          EXECUTION_FIFO_QUEUE_URL: !Ref ExecutionFifoQueue
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  PortfolioExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: PortfolioPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              # Per-trade parallel execution: SQS Standard queue access (named *Fifo for AWS compatibility)
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:GetQueueAttributes
                Resource:
                  - !GetAtt ExecutionFifoQueue.Arn
              # Per-trade execution: Execution runs table access
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn
              # Rebalance plan persistence for auditability
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt RebalancePlanTable.Arn
                  - !Sub "${RebalancePlanTable.Arn}/index/*"

  # Execution Lambda - Trade execution microservice (triggered via SQS)
  ExecutionFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution"
        - !Sub "alchemiser-${Stage}-execution"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.execution_v2.lambda_handler.lambda_handler
      Role: !GetAtt ExecutionExecutionRole.Arn
      Layers:
        - !Ref ExecutionLayer
      Timeout: 600
      MemorySize: 1024
      # Concurrency limited to 10 for Alpaca trading API rate limits (200 calls/min)
      # WebSocket handles order status updates, so each trade only makes ~1-2 REST calls
      # 10 concurrent = ~2-4 calls/sec (well under 3.33/sec limit)
      ReservedConcurrentExecutions: 10
      # WebSocket connections are cleaned up after each execution via cleanup_all_instances()
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          ALPACA__KEY: !If [ IsDev, !Ref AlpacaKey, !Ref ProdAlpacaKey ]
          ALPACA__SECRET: !If [ IsDev, !Ref AlpacaSecret, !Ref ProdAlpacaSecret ]
          ALPACA__ENDPOINT: !If [ IsDev, !Ref AlpacaEndpoint, !Ref ProdAlpacaEndpoint ]
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # Per-trade execution configuration
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
          # Queue URL for triggering BUY phase after SELL phase completes
          EXECUTION_FIFO_QUEUE_URL: !Ref ExecutionFifoQueue
      Events:
        ExecutionQueue:
          Type: SQS
          Properties:
            Queue: !GetAtt ExecutionQueue.Arn
            BatchSize: 1
            FunctionResponseTypes:
              - ReportBatchItemFailures
        # Per-trade parallel execution: Standard queue (resource named *Fifo for AWS compatibility)
        ExecutionFifoQueue:
          Type: SQS
          Properties:
            Queue: !GetAtt ExecutionFifoQueue.Arn
            BatchSize: 1
            FunctionResponseTypes:
              - ReportBatchItemFailures
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  ExecutionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ExecutionPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sqs:SendMessage  # For triggering BUY phase after SELL phase completes
                Resource:
                  - !GetAtt ExecutionQueue.Arn
                  - !GetAtt ExecutionFifoQueue.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:BatchWriteItem
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              # Per-trade execution: Execution runs table access
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn

  # ========== TRADE AGGREGATOR LAMBDA ==========
  # Aggregates TradeExecuted events and emits single AllTradesCompleted event
  # This eliminates race conditions in notifications by ensuring only one notification per run
  TradeAggregatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-trade-aggregator"
        - !Sub "alchemiser-${Stage}-trade-aggregator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.trade_aggregator.lambda_handler.lambda_handler
      Role: !GetAtt TradeAggregatorExecutionRole.Arn
      Layers:
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog, alpaca-py for capital metrics)
      Timeout: 60  # Aggregation should be fast
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
      Events:
        TradeExecutedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.execution"
              detail-type:
                - "TradeExecuted"
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  TradeAggregatorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: TradeAggregatorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn

  # ========== NOTIFICATIONS LAMBDA ==========
  # Consumes TradeExecuted and WorkflowFailed events and sends email notifications
  NotificationsFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-notifications"
        - !Sub "alchemiser-${Stage}-notifications"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.notifications_v2.lambda_handler.lambda_handler
      Role: !GetAtt NotificationsExecutionRole.Arn
      Layers:
        - !Ref NotificationsLayer
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          SNS_NOTIFICATION_TOPIC_ARN: !Ref TradingNotificationsTopic
          PERFORMANCE_REPORTS_BUCKET: !Ref PerformanceReportsBucket
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
      Events:
        # AllTradesCompleted from TradeAggregator (one event per run, no racing)
        AllTradesCompletedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.trade_aggregator"
              detail-type:
                - "AllTradesCompleted"
        # Route WorkflowFailed from ANY alchemiser source to notifications
        # Each Lambda (strategy, portfolio, execution) publishes WorkflowFailed with its own source
        WorkflowFailedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - prefix: "alchemiser."
              detail-type:
                - "WorkflowFailed"
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  NotificationsExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: NotificationsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Ref TradingNotificationsTopic
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:GetItem
                  - dynamodb:Scan
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  - !Sub "${PerformanceReportsBucket.Arn}/*"

  # ========== METRICS LAMBDA (PRODUCTION ONLY) ==========
  # Publishes per-strategy realized P&L metrics to CloudWatch for dashboard visualization
  MetricsFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "alchemiser-${Stage}-metrics"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.metrics_v2.lambda_handler.lambda_handler
      Role: !GetAtt MetricsExecutionRole.Arn
      Layers:
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog, boto3)
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          STAGE: !Ref Stage
      Events:
        TradeExecutedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.execution"
              detail-type:
                - "TradeExecuted"
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  MetricsExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: MetricsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:GetItem
                  - dynamodb:Scan
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: "*"

  # Scheduler to trigger Strategy Orchestrator (workflow entry point)
  # Orchestrator fans out to Strategy Workers for parallel execution
  StrategySchedule:
    Type: AWS::Scheduler::Schedule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-schedule"
        - !Sub "alchemiser-${Stage}-strategy-schedule"
      Description: "Execute trading strategy daily at ~3:30 PM New York time (within 3:30-3:45 PM window)"
      ScheduleExpression: "cron(30 15 ? * MON-FRI *)"
      ScheduleExpressionTimezone: "America/New_York"
      FlexibleTimeWindow: !If
        - IsProduction
        - Mode: "OFF"
        - Mode: FLEXIBLE
          MaximumWindowInMinutes: 15
      Target:
        Arn: !GetAtt StrategyOrchestratorFunction.Arn
        RoleArn: !GetAtt StrategySchedulerRole.Arn
        Input: '{"mode": "trade"}'
        RetryPolicy:
          MaximumRetryAttempts: 1

  StrategySchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: scheduler.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeStrategy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt StrategyFunction.Arn
                  - !GetAtt StrategyOrchestratorFunction.Arn

  # ============================================================================
  # END MICROSERVICES ARCHITECTURE
  # ============================================================================
  # Note: Data Lambda moved to shared infrastructure (data-template.yaml)
  # The shared Data Lambda serves all stages from alchemiser-shared-data

  # ============================================================================
  # OBSERVABILITY: CloudWatch Logs Insights & Dashboard
  # ============================================================================
  
  # CloudWatch Dashboard for at-a-glance monitoring
  # Note: Log groups are auto-created by Lambda; we reference them by name
  AlchemiserDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-monitoring"
        - !Sub "alchemiser-${Stage}-monitoring"
      DashboardBody: !Sub
        - |
          {
            "widgets": [
              {
                "type": "log",
                "properties": {
                  "title": "Latest Errors & Warnings (All Lambdas)",
                  "region": "${AWS::Region}",
                  "query": "SOURCE '${StrategyLog}'\n| SOURCE '${OrchestratorLog}'\n| SOURCE '${AggregatorLog}'\n| SOURCE '${PortfolioLog}'\n| SOURCE '${ExecutionLog}'\n| SOURCE '${NotificationsLog}'\n| SOURCE '${MetricsLog}'\n| SOURCE '${DataLog}'\n| fields @timestamp, @log, level, event, module, correlation_id, message\n| filter level in ['error', 'warn', 'warning']\n| sort @timestamp desc\n| limit 50"
                },
                "x": 0,
                "y": 0,
                "width": 24,
                "height": 8
              },
              {
                "type": "log",
                "properties": {
                  "title": "Errors by Correlation ID (Trace Workflow Runs)",
                  "region": "${AWS::Region}",
                  "query": "SOURCE '${StrategyLog}'\n| SOURCE '${OrchestratorLog}'\n| SOURCE '${AggregatorLog}'\n| SOURCE '${PortfolioLog}'\n| SOURCE '${ExecutionLog}'\n| SOURCE '${NotificationsLog}'\n| SOURCE '${MetricsLog}'\n| SOURCE '${DataLog}'\n| fields @timestamp, @log, level, event, module, correlation_id, message\n| filter level = 'error'\n| sort @timestamp desc\n| limit 100"
                },
                "x": 0,
                "y": 8,
                "width": 24,
                "height": 8
              },
              {
                "type": "log",
                "properties": {
                  "title": "Recent Workflow Runs (by correlation_id)",
                  "region": "${AWS::Region}",
                  "query": "SOURCE '${StrategyLog}'\n| SOURCE '${OrchestratorLog}'\n| SOURCE '${AggregatorLog}'\n| SOURCE '${PortfolioLog}'\n| SOURCE '${ExecutionLog}'\n| SOURCE '${NotificationsLog}'\n| SOURCE '${MetricsLog}'\n| SOURCE '${DataLog}'\n| fields @timestamp, @log, level, event, correlation_id, module\n| filter event like /SignalGenerated|PartialSignalGenerated|RebalancePlanned|TradeExecuted|WorkflowCompleted|WorkflowFailed/\n| sort @timestamp desc\n| limit 50"
                },
                "x": 0,
                "y": 16,
                "width": 24,
                "height": 8
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Realized P&L by Strategy (Last 30 Days)",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 86400,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "RealizedPnL", { "stat": "Sum" } ]
                  ],
                  "yAxis": {
                    "left": {
                      "label": "P&L ($)"
                    }
                  },
                  "view": "timeSeries",
                  "stacked": false
                },
                "x": 0,
                "y": 24,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Cumulative Realized P&L (All Strategies)",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 2592000,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "RealizedPnL", { "stat": "Sum" } ]
                  ],
                  "view": "singleValue"
                },
                "x": 12,
                "y": 24,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Trade Count (Last 7 Days)",
                  "region": "${AWS::Region}",
                  "stat": "SampleCount",
                  "period": 86400,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "RealizedPnL", { "stat": "SampleCount" } ]
                  ],
                  "yAxis": {
                    "left": {
                      "label": "Trades"
                    }
                  },
                  "view": "timeSeries",
                  "stacked": false
                },
                "x": 18,
                "y": 24,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Capital Deployed (Last 7 Days)",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 86400,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "CapitalDeployedPct", { "stat": "Average" } ]
                  ],
                  "yAxis": {
                    "left": {
                      "label": "%",
                      "min": 0,
                      "max": 100
                    }
                  },
                  "view": "timeSeries",
                  "stacked": false
                },
                "x": 0,
                "y": 30,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Current Capital Deployed",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 300,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "CapitalDeployedPct", { "stat": "Average" } ]
                  ],
                  "view": "singleValue"
                },
                "x": 12,
                "y": 30,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "P&L by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 86400,
                  "view": "timeSeries",
                  "stacked": false,
                  "yAxis": { "left": { "label": "P&L ($)" } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} RealizedPnL', 'Sum', 86400)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 0,
                "y": 36,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Win Rate by Strategy (%)",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 86400,
                  "view": "timeSeries",
                  "stacked": false,
                  "yAxis": { "left": { "label": "%", "min": 0, "max": 100 } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} WinRate', 'Average', 86400)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 12,
                "y": 36,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Open Position Value by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 3600,
                  "view": "timeSeries",
                  "stacked": true,
                  "yAxis": { "left": { "label": "Value ($)" } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} OpenPositionValue', 'Average', 3600)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 0,
                "y": 42,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Open Lots by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 3600,
                  "view": "timeSeries",
                  "stacked": true,
                  "yAxis": { "left": { "label": "Count", "min": 0 } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} OpenLotCount', 'Average', 3600)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 12,
                "y": 42,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Closed Lots by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 86400,
                  "view": "timeSeries",
                  "stacked": true,
                  "yAxis": { "left": { "label": "Count", "min": 0 } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} ClosedLotCount', 'Sum', 86400)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 18,
                "y": 42,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Winning vs Losing Trades by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 86400,
                  "view": "bar",
                  "stacked": false,
                  "yAxis": { "left": { "label": "Count" } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} WinningTrades', 'Average', 86400)", "label": "", "id": "e1" } ],
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} LosingTrades', 'Average', 86400)", "label": "", "id": "e2" } ]
                  ]
                },
                "x": 0,
                "y": 48,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Avg Profit per Trade by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 86400,
                  "view": "timeSeries",
                  "stacked": false,
                  "yAxis": { "left": { "label": "$ per trade" } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} AvgProfitPerTrade', 'Average', 86400)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 12,
                "y": 48,
                "width": 12,
                "height": 6
              }
            ]
          }
        - StrategyLog: !Sub "/aws/lambda/${StrategyFunction}"
          OrchestratorLog: !Sub "/aws/lambda/${StrategyOrchestratorFunction}"
          AggregatorLog: !Sub "/aws/lambda/${StrategyAggregatorFunction}"
          PortfolioLog: !Sub "/aws/lambda/${PortfolioFunction}"
          ExecutionLog: !Sub "/aws/lambda/${ExecutionFunction}"
          NotificationsLog: !Sub "/aws/lambda/${NotificationsFunction}"
          MetricsLog: !Sub "/aws/lambda/${MetricsFunction}"
          DataLog: "/aws/lambda/alchemiser-shared-data"
          StageTitle: !FindInMap [StageConfig, !Ref Stage, TitleCase]

Outputs:
  TradeLedgerTableName:
    Description: "DynamoDB table for trade ledger persistence"
    Value: !Ref TradeLedgerTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-TradeLedgerTable"
        - !Sub "alchemiser-${Stage}-TradeLedgerTable"

  AggregationSessionsTableName:
    Description: "DynamoDB table for multi-node strategy aggregation sessions"
    Value: !Ref AggregationSessionsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-AggregationSessionsTable"
        - !Sub "alchemiser-${Stage}-AggregationSessionsTable"

  ExecutionRunsTableName:
    Description: "DynamoDB table for per-trade execution run tracking"
    Value: !Ref ExecutionRunsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-ExecutionRunsTable"
        - !Sub "alchemiser-${Stage}-ExecutionRunsTable"

  RebalancePlanTableName:
    Description: "DynamoDB table for rebalance plan auditability (90-day TTL)"
    Value: !Ref RebalancePlanTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-RebalancePlanTable"
        - !Sub "alchemiser-${Stage}-RebalancePlanTable"

  ExecutionFifoQueueUrl:
    Description: "SQS Standard queue for parallel per-trade execution"
    Value: !Ref ExecutionFifoQueue
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-ExecutionFifoQueue"
        - !Sub "alchemiser-${Stage}-ExecutionFifoQueue"

  PerformanceReportsBucketName:
    Description: "S3 bucket for strategy performance CSV reports"
    Value: !Ref PerformanceReportsBucket
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-PerformanceReportsBucket"
        - !Sub "alchemiser-${Stage}-PerformanceReportsBucket"

  MarketDataBucketName:
    Description: "Shared S3 bucket for historical market data (Parquet files)"
    Value: !Ref SharedMarketDataBucket
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-MarketDataBucket"
        - !Sub "alchemiser-${Stage}-MarketDataBucket"

  DeploymentStage:
    Description: "Deployed stage"
    Value: !Ref Stage
  
  StackNameUsed:
    Description: "Stack name used for resource naming"
    Value: !If [ HasStackName, !Ref StackName, !Sub "alchemiser-${Stage}" ]


  DashboardURL:
    Description: "CloudWatch Dashboard for monitoring errors and warnings"
    Value: !Sub "https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${AlchemiserDashboard}"

  LogsInsightsURL:
    Description: "CloudWatch Logs Insights for querying logs across all Lambdas"
    Value: !Sub "https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#logsV2:logs-insights"

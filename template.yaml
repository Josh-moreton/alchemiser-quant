# yaml-language-server: $schema=https://raw.githubusercontent.com/aws/serverless-application-model/main/samtranslator/validator/sam_schema/schema.json
# yaml-language-server: disable-validation
AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: >
  The Alchemiser Quantitative Trading System

  Multi-strategy algorithmic trading engine deployed as an AWS Lambda Function

Parameters:
  Stage:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - prod
      - ephemeral
    Description: Deployment stage (dev, prod, or ephemeral)
  
  StackName:
    Type: String
    Default: ""
    Description: Optional override for stack-specific resource naming (used for ephemeral stacks)
  
  Env:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - prod
      - ephemeral
    Description: Environment type for resource configuration
  
  ArtifactPrefix:
    Type: String
    Default: ""
    Description: S3 prefix for artifacts (used for ephemeral stack isolation)

  AlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key (used only in dev; leave blank for prod)

  AlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret (used only in dev; leave blank for prod)

  AlpacaEndpoint:
    Type: String
    Default: https://paper-api.alpaca.markets/v2
    Description: Alpaca API endpoint; defaults to paper for dev, live is used for prod

  EmailPassword:
    Type: String
    Default: ""
    NoEcho: true
    Description: Email SMTP password for dev notifications (optional)

  # Runtime configuration parameters (override via CD for each environment)
  DslMaxWorkers:
    Type: String
    Default: "7"
    Description: ALCHEMISER_DSL_MAX_WORKERS (string to align with Lambda env var type)

  # Margin/Leverage configuration
  EquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: ALPACA__EQUITY_DEPLOYMENT_PCT - percentage of equity to deploy (1.0=100%, 1.10=110% with margin)

  ProdEquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: Equity deployment percentage for production (conservative default)

  # Production-only parameters (only used when Stage=prod)
  ProdAlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key for production (required when Stage=prod)

  ProdAlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret for production (required when Stage=prod)

  ProdAlpacaEndpoint:
    Type: String
    Default: https://api.alpaca.markets
    Description: Alpaca API endpoint for production

  ProdEmailPassword:
    Type: String
    Default: ""
    NoEcho: true
    Description: Email SMTP password for production notifications (optional)

  # Multi-node strategy scaling
  EnableMultiNodeStrategy:
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description: Enable multi-node strategy scaling (fan-out to parallel Lambda invocations)

  # Per-trade execution scaling
  EnablePerTradeExecution:
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description: Enable per-trade execution scaling (one Lambda invocation per trade via SQS FIFO)

  # Strategy configuration: now defined in code defaults. Override via env only if required.

Mappings:
  StageConfig:
    dev:
      TitleCase: "Dev"
    prod:
      TitleCase: "Production"
    ephemeral:
      TitleCase: "Ephemeral"

Conditions:
  IsDev: !Equals [ !Ref Stage, dev ]
  IsProduction: !Equals [ !Ref Stage, prod ]
  IsEphemeral: !Equals [ !Ref Stage, ephemeral ]
  HasStackName: !Not [ !Equals [ !Ref StackName, "" ] ]
  UseStackNameForResources: !Or [ !Condition IsEphemeral, !Condition HasStackName ]
  EnableMultiNode: !Equals [ !Ref EnableMultiNodeStrategy, "true" ]
  EnablePerTrade: !Equals [ !Ref EnablePerTradeExecution, "true" ]

Globals:
  Function:
    Timeout: 900 # 15 minutes - max for Lambda
    MemorySize: 512
    Environment:
      Variables:
        # Stage awareness for code-level profiles
        APP__STAGE: !If [ IsDev, "dev", "prod" ]
        # Alpaca Configuration
        ALPACA__KEY: !If [ IsDev, !Ref AlpacaKey, !Ref ProdAlpacaKey ]
        ALPACA__SECRET: !If [ IsDev, !Ref AlpacaSecret, !Ref ProdAlpacaSecret ]
        ALPACA__ENDPOINT: !If [ IsDev, !Ref AlpacaEndpoint, !Ref ProdAlpacaEndpoint ]
        # Email Configuration
        EMAIL__SMTP_SERVER: smtp.mail.me.com
        EMAIL__SMTP_PORT: 587
        EMAIL__FROM_EMAIL: joshuamoreton1@icloud.com
        EMAIL__TO_EMAIL: notifications@rwxt.org
        EMAIL__NEUTRAL_MODE: true
        EMAIL__PASSWORD: !If [ IsDev, !Ref EmailPassword, !Ref ProdEmailPassword ]
        # Strategy DSL configuration now comes from code defaults; override via env only if necessary
        # STRATEGY__DSL_FILES: '["1-KMLM.clj","2-Nuclear.clj","5-Coin.clj","6-TQQQ-FLT.clj"]'
        # STRATEGY__DSL_ALLOCATIONS: '{"1-KMLM.clj":0.4,"2-Nuclear.clj":0.25,"5-Coin.clj":0.1,"6-TQQQ-FLT.clj":0.25}'

        # DSL parallelism configuration
        ALCHEMISER_DSL_MAX_WORKERS: !Ref DslMaxWorkers

        # Margin/Leverage configuration - controls how much of equity to deploy
        # 1.0 = 100% of equity (no margin), 1.10 = 110% (10% margin usage)
        ALPACA__EQUITY_DEPLOYMENT_PCT: !If [ IsDev, !Ref EquityDeploymentPct, !Ref ProdEquityDeploymentPct ]

        # Trade ledger DynamoDB table
        TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable

  # Strategy configuration now packaged with code; env overrides optional

  # (no additional Globals keys)

Resources:
  # DynamoDB Table for trade ledger persistence
  TradeLedgerTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-trade-ledger"
        - !Sub "alchemiser-${Stage}-trade-ledger"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
        - AttributeName: GSI1PK
          AttributeType: S
        - AttributeName: GSI1SK
          AttributeType: S
        - AttributeName: GSI2PK
          AttributeType: S
        - AttributeName: GSI2SK
          AttributeType: S
        - AttributeName: GSI3PK
          AttributeType: S
        - AttributeName: GSI3SK
          AttributeType: S
        - AttributeName: GSI4PK
          AttributeType: S
        - AttributeName: GSI4SK
          AttributeType: S
        - AttributeName: GSI5PK
          AttributeType: S
        - AttributeName: GSI5SK
          AttributeType: S
        - AttributeName: GSI6PK
          AttributeType: S
        - AttributeName: GSI6SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      GlobalSecondaryIndexes:
        # GSI1: Query by correlation_id
        - IndexName: GSI1-CorrelationIndex
          KeySchema:
            - AttributeName: GSI1PK
              KeyType: HASH
            - AttributeName: GSI1SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI2: Query by symbol
        - IndexName: GSI2-SymbolIndex
          KeySchema:
            - AttributeName: GSI2PK
              KeyType: HASH
            - AttributeName: GSI2SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI3: Query by strategy
        - IndexName: GSI3-StrategyIndex
          KeySchema:
            - AttributeName: GSI3PK
              KeyType: HASH
            - AttributeName: GSI3SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI4: Query snapshots by correlation_id
        - IndexName: GSI4-CorrelationSnapshotIndex
          KeySchema:
            - AttributeName: GSI4PK
              KeyType: HASH
            - AttributeName: GSI4SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI5: Query strategy lots by strategy name (for FIFO P&L tracking)
        - IndexName: GSI5-StrategyLotsIndex
          KeySchema:
            - AttributeName: GSI5PK
              KeyType: HASH
            - AttributeName: GSI5SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI6: Query strategy lots by symbol (cross-strategy position analysis)
        - IndexName: GSI6-SymbolLotsIndex
          KeySchema:
            - AttributeName: GSI6PK
              KeyType: HASH
            - AttributeName: GSI6SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      
      SSESpecification:
        SSEEnabled: true
        # Use AWS-managed encryption (not KMS) to avoid requiring additional IAM permissions
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: trade-ledger

  # ========== AGGREGATION SESSIONS TABLE (MULTI-NODE SCALING) ==========
  # DynamoDB Table for tracking multi-node strategy aggregation sessions
  AggregationSessionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-aggregation-sessions"
        - !Sub "alchemiser-${Stage}-aggregation-sessions"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: aggregation-sessions

  # ========== EXECUTION RUNS TABLE (PER-TRADE SCALING) ==========
  # DynamoDB Table for tracking per-trade execution run state
  # Follows same pattern as AggregationSessionsTable for Strategy multi-node
  ExecutionRunsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-execution-runs"
        - !Sub "alchemiser-${Stage}-execution-runs"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: execution-runs

  # ========== REBALANCE PLAN TABLE (AUDITABILITY) ==========
  # DynamoDB Table for persisting RebalancePlan documents with 90-day TTL
  # Enables "why didn't we trade X?" queries beyond EventBridge's 24-hour retention
  RebalancePlanTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-rebalance-plans"
        - !Sub "alchemiser-${Stage}-rebalance-plans"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
        - AttributeName: GSI1PK
          AttributeType: S
        - AttributeName: GSI1SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      GlobalSecondaryIndexes:
        # GSI1: Query by correlation_id for tracing workflow decisions
        - IndexName: GSI1-CorrelationIndex
          KeySchema:
            - AttributeName: GSI1PK
              KeyType: HASH
            - AttributeName: GSI1SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: rebalance-plans

  # ========== FUNCTION-SPECIFIC LAMBDA LAYERS ==========
  # Each Lambda gets its own optimized layer with only required dependencies
  # boto3/botocore excluded from all layers - Lambda runtime provides them

  # Strategy Layer: awswrangler (pandas, numpy, pyarrow) + alpaca-py
  # Built via Makefile: downloads pre-built awswrangler, adds alpaca-py
  StrategyLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-deps"
        - !Sub "alchemiser-${Stage}-strategy-deps"
      Description: awswrangler 3.10.0 + alpaca-py (pandas, numpy, pyarrow included)
      ContentUri: layers/strategy/
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - x86_64
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: makefile

  # Portfolio Layer: alpaca-py + pydantic (no pandas/numpy)
  PortfolioLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-portfolio-deps"
        - !Sub "alchemiser-${Stage}-portfolio-deps"
      Description: Portfolio Lambda dependencies (alpaca-py, pydantic)
      ContentUri: layers/portfolio/
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # Execution Layer: alpaca-py + pydantic (no pandas/numpy)
  ExecutionLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-deps"
        - !Sub "alchemiser-${Stage}-execution-deps"
      Description: Execution Lambda dependencies (alpaca-py, pydantic)
      ContentUri: layers/execution/
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # Notifications Layer: pydantic + structlog (minimal footprint)
  NotificationsLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-notifications-deps"
        - !Sub "alchemiser-${Stage}-notifications-deps"
      Description: Notifications Lambda dependencies (pydantic, structlog)
      ContentUri: layers/notifications/
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # Data Layer: awswrangler (pandas, numpy, pyarrow) + alpaca-py
  # Built via Makefile: downloads pre-built awswrangler, adds alpaca-py
  # Total size: ~186MB unzipped (under 250MB limit)
  DataLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-data-deps"
        - !Sub "alchemiser-${Stage}-data-deps"
      Description: awswrangler 3.10.0 + alpaca-py (pandas, numpy, pyarrow included)
      ContentUri: layers/data/
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - x86_64
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: makefile

  # ============================================================================
  # MICROSERVICES ARCHITECTURE
  # ============================================================================

  # EventBridge Event Bus for async domain event communication
  AlchemiserEventBus:
    Type: AWS::Events::EventBus
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-events"
        - !Sub "alchemiser-${Stage}-events"

  # SQS Queue for reliable trade execution with DLQ
  ExecutionQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-queue"
        - !Sub "alchemiser-${Stage}-execution-queue"
      VisibilityTimeout: 900  # 15 mins for execution
      MessageRetentionPeriod: 345600  # 4 days
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ExecutionDLQ.Arn
        maxReceiveCount: 3

  ExecutionDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-dlq"
        - !Sub "alchemiser-${Stage}-execution-dlq"
      MessageRetentionPeriod: 1209600  # 14 days

  # SQS FIFO Queue for per-trade execution (used when EnablePerTradeExecution=true)
  # FIFO guarantees ordering: sells processed before buys via sequence numbers in MessageGroupId
  ExecutionFifoQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-fifo.fifo"
        - !Sub "alchemiser-${Stage}-execution-fifo.fifo"
      FifoQueue: true
      ContentBasedDeduplication: false  # Use explicit MessageDeduplicationId (trade_id)
      VisibilityTimeout: 900  # 15 mins for execution
      MessageRetentionPeriod: 345600  # 4 days
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ExecutionFifoDLQ.Arn
        maxReceiveCount: 3

  ExecutionFifoDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-fifo-dlq.fifo"
        - !Sub "alchemiser-${Stage}-execution-fifo-dlq.fifo"
      FifoQueue: true
      MessageRetentionPeriod: 1209600  # 14 days

  # SNS Topic for DLQ alerts (very low cost: ~$0.50/million messages)
  DLQAlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-dlq-alerts"
        - !Sub "alchemiser-${Stage}-dlq-alerts"
      DisplayName: "Alchemiser DLQ Alert"

  # Email subscription for DLQ alerts
  DLQAlertEmailSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref DLQAlertTopic
      Protocol: email
      Endpoint: notifications@rwxt.org

  # ========== PERFORMANCE REPORTS S3 BUCKET ==========
  # S3 bucket for strategy performance CSV reports with presigned URL access
  PerformanceReportsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !If
        - HasStackName
        - !Sub "${StackName}-performance-reports"
        - !Sub "alchemiser-${Stage}-reports"
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldReports
            ExpirationInDays: 30
            Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: performance-reports

  # ========== MARKET DATA S3 BUCKET ==========
  # S3 bucket for historical market data (Parquet files) with versioning
  MarketDataBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !If
        - HasStackName
        - !Sub "${StackName}-historical-market-data"
        - !Sub "alchemiser-${Stage}-market-data"
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: market-data

  # ========== TRADING NOTIFICATIONS SNS ==========
  # SNS Topic for trading notifications (trade results, workflow failures)
  TradingNotificationsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-trading-notifications"
        - !Sub "alchemiser-${Stage}-trading-notifications"
      DisplayName: "Alchemiser Trading Notifications"

  # Email subscription for trading notifications
  TradingNotificationsEmailSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref TradingNotificationsTopic
      Protocol: email
      Endpoint: notifications@rwxt.org

  # CloudWatch Alarm for DLQ messages (triggers when messages hit DLQ)
  DLQMessageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-dlq-messages"
        - !Sub "alchemiser-${Stage}-dlq-messages"
      AlarmDescription: "Alert when messages land in the execution DLQ after 3 failed attempts"
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: QueueName
          Value: !GetAtt ExecutionDLQ.QueueName
      AlarmActions:
        - !Ref DLQAlertTopic
      TreatMissingData: notBreaching

  # CloudWatch Alarm for FIFO DLQ messages (per-trade execution failures)
  FifoDLQMessageAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: EnablePerTrade
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-fifo-dlq-messages"
        - !Sub "alchemiser-${Stage}-fifo-dlq-messages"
      AlarmDescription: "Alert when per-trade execution messages hit FIFO DLQ after 3 retries"
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: QueueName
          Value: !GetAtt ExecutionFifoDLQ.QueueName
      AlarmActions:
        - !Ref DLQAlertTopic
      TreatMissingData: notBreaching

  # CloudWatch Alarm for stuck execution runs (RUNNING > 30 mins)
  # Detects orphaned runs where trades never completed
  StuckRunsAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: EnablePerTrade
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-stuck-execution-runs"
        - !Sub "alchemiser-${Stage}-stuck-execution-runs"
      AlarmDescription: "Alert when execution runs are stuck in RUNNING state for >30 minutes"
      MetricName: StuckRuns
      Namespace: Alchemiser/Execution
      Statistic: Maximum
      Period: 300  # 5 minutes
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: TableName
          Value: !Ref ExecutionRunsTable
      AlarmActions:
        - !Ref DLQAlertTopic
      TreatMissingData: notBreaching

  # Policy to allow EventBridge to send messages to SQS
  ExecutionQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues:
        - !Ref ExecutionQueue
      PolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sqs:SendMessage
            Resource: !GetAtt ExecutionQueue.Arn
            Condition:
              ArnEquals:
                aws:SourceArn: !GetAtt RebalancePlannedRule.Arn

  # EventBridge Rules for event routing
  SignalGeneratedRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-signal-generated"
        - !Sub "alchemiser-${Stage}-signal-generated"
      EventBusName: !Ref AlchemiserEventBus
      EventPattern:
        source:
          - alchemiser.strategy
        detail-type:
          - SignalGenerated
      Targets:
        - Id: PortfolioTarget
          Arn: !GetAtt PortfolioFunction.Arn

  SignalGeneratedPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PortfolioFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt SignalGeneratedRule.Arn

  RebalancePlannedRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-rebalance-planned"
        - !Sub "alchemiser-${Stage}-rebalance-planned"
      EventBusName: !Ref AlchemiserEventBus
      EventPattern:
        source:
          - alchemiser.portfolio
        detail-type:
          - RebalancePlanned
      Targets:
        - Id: ExecutionQueueTarget
          Arn: !GetAtt ExecutionQueue.Arn

  # Strategy Worker Lambda - Executes strategy DSL files (invoked by orchestrator or directly)
  StrategyFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-worker"
        - !Sub "alchemiser-${Stage}-strategy-worker"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.strategy_v2.lambda_handler.lambda_handler
      Role: !GetAtt StrategyExecutionRole.Arn
      Layers:
        - !Ref StrategyLayer  # awswrangler + alpaca-py (built via Makefile)
      Timeout: 900  # Max timeout for on-demand data fetching
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          MARKET_DATA_BUCKET: !Ref MarketDataBucket
          ALPACA__KEY: !If [ IsDev, !Ref AlpacaKey, !Ref ProdAlpacaKey ]
          ALPACA__SECRET: !If [ IsDev, !Ref AlpacaSecret, !Ref ProdAlpacaSecret ]
          ALPACA__ENDPOINT: !If [ IsDev, !Ref AlpacaEndpoint, !Ref ProdAlpacaEndpoint ]
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          ALCHEMISER_DSL_MAX_WORKERS: !Ref DslMaxWorkers
          # Multi-node strategy scaling
          ENABLE_MULTI_NODE_STRATEGY: !Ref EnableMultiNodeStrategy
          # Data Lambda for market data (bars from S3 Parquet)
          DATA_FUNCTION_NAME: !Ref DataFunction
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  StrategyExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              # Permission to invoke Data Lambda for market data
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt DataFunction.Arn
              # S3 permissions for market data bucket (freshness validation)
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !GetAtt MarketDataBucket.Arn
                  - !Sub "${MarketDataBucket.Arn}/*"

  # ========== MULTI-NODE STRATEGY SCALING (Orchestrator + Aggregator) ==========
  # These Lambdas enable horizontal scaling of strategy execution by running
  # each DSL file in a separate Lambda invocation and aggregating the results.

  # Strategy Orchestrator Lambda - Entry point that dispatches parallel strategy execution
  StrategyOrchestratorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-orchestrator"
        - !Sub "alchemiser-${Stage}-strategy-orchestrator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.coordinator_v2.lambda_handler.lambda_handler
      Role: !GetAtt StrategyOrchestratorExecutionRole.Arn
      Layers:
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog)
      Timeout: 60  # Orchestrator just dispatches, doesn't run strategies
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          AGGREGATION_TABLE_NAME: !Ref AggregationSessionsTable
          STRATEGY_FUNCTION_NAME: !Ref StrategyFunction
          AGGREGATION_TIMEOUT_SECONDS: "600"
          ENABLE_MULTI_NODE_STRATEGY: !Ref EnableMultiNodeStrategy
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  StrategyOrchestratorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyOrchestratorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt AggregationSessionsTable.Arn
              # Permission to invoke Strategy Lambda for each file
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                  - lambda:InvokeAsync
                Resource:
                  - !GetAtt StrategyFunction.Arn

  # Signal Aggregator Lambda - Aggregates partial strategy signals into consolidated portfolio
  StrategyAggregatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-signal-aggregator"
        - !Sub "alchemiser-${Stage}-signal-aggregator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.aggregator_v2.lambda_handler.lambda_handler
      Role: !GetAtt StrategyAggregatorExecutionRole.Arn
      Layers:
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog)
      Timeout: 60  # Aggregation should be fast
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          AGGREGATION_TABLE_NAME: !Ref AggregationSessionsTable
          ALLOCATION_TOLERANCE: "0.01"
      Events:
        PartialSignalEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.strategy"
              detail-type:
                - "PartialSignalGenerated"
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  StrategyAggregatorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyAggregatorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt AggregationSessionsTable.Arn

  # ========== END MULTI-NODE STRATEGY SCALING ==========

  # Portfolio Lambda - Rebalance planning microservice
  PortfolioFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-portfolio"
        - !Sub "alchemiser-${Stage}-portfolio"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.portfolio_v2.lambda_handler.lambda_handler
      Role: !GetAtt PortfolioExecutionRole.Arn
      Layers:
        - !Ref PortfolioLayer
      Timeout: 900  # Max timeout for comprehensive processing
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          ALPACA__KEY: !If [ IsDev, !Ref AlpacaKey, !Ref ProdAlpacaKey ]
          ALPACA__SECRET: !If [ IsDev, !Ref AlpacaSecret, !Ref ProdAlpacaSecret ]
          ALPACA__ENDPOINT: !If [ IsDev, !Ref AlpacaEndpoint, !Ref ProdAlpacaEndpoint ]
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # Rebalance plan persistence for auditability
          REBALANCE_PLAN__TABLE_NAME: !Ref RebalancePlanTable
          # Per-trade execution configuration
          ENABLE_PER_TRADE_EXECUTION: !Ref EnablePerTradeExecution
          EXECUTION_FIFO_QUEUE_URL: !Ref ExecutionFifoQueue
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  PortfolioExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: PortfolioPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              # Per-trade execution: SQS FIFO queue access
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:GetQueueAttributes
                Resource:
                  - !GetAtt ExecutionFifoQueue.Arn
              # Per-trade execution: Execution runs table access
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn
              # Rebalance plan persistence for auditability
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt RebalancePlanTable.Arn
                  - !Sub "${RebalancePlanTable.Arn}/index/*"

  # Execution Lambda - Trade execution microservice (triggered via SQS)
  ExecutionFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution"
        - !Sub "alchemiser-${Stage}-execution"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.execution_v2.lambda_handler.lambda_handler
      Role: !GetAtt ExecutionExecutionRole.Arn
      Layers:
        - !Ref ExecutionLayer
      Timeout: 600
      MemorySize: 1024
      # Note: Concurrency is limited by SQS BatchSize: 1 which processes one message at a time
      # WebSocket connections are cleaned up after each execution via cleanup_all_instances()
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          ALPACA__KEY: !If [ IsDev, !Ref AlpacaKey, !Ref ProdAlpacaKey ]
          ALPACA__SECRET: !If [ IsDev, !Ref AlpacaSecret, !Ref ProdAlpacaSecret ]
          ALPACA__ENDPOINT: !If [ IsDev, !Ref AlpacaEndpoint, !Ref ProdAlpacaEndpoint ]
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # Per-trade execution configuration
          ENABLE_PER_TRADE_EXECUTION: !Ref EnablePerTradeExecution
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
      Events:
        ExecutionQueue:
          Type: SQS
          Properties:
            Queue: !GetAtt ExecutionQueue.Arn
            BatchSize: 1
            FunctionResponseTypes:
              - ReportBatchItemFailures
        # Per-trade execution: FIFO queue trigger
        ExecutionFifoQueue:
          Type: SQS
          Properties:
            Queue: !GetAtt ExecutionFifoQueue.Arn
            BatchSize: 1
            FunctionResponseTypes:
              - ReportBatchItemFailures
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  ExecutionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ExecutionPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                Resource:
                  - !GetAtt ExecutionQueue.Arn
                  - !GetAtt ExecutionFifoQueue.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:BatchWriteItem
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              # Per-trade execution: Execution runs table access
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn

  # ========== NOTIFICATIONS LAMBDA ==========
  # Consumes TradeExecuted and WorkflowFailed events and sends email notifications
  NotificationsFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-notifications"
        - !Sub "alchemiser-${Stage}-notifications"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.notifications_v2.lambda_handler.lambda_handler
      Role: !GetAtt NotificationsExecutionRole.Arn
      Layers:
        - !Ref NotificationsLayer
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          SNS_NOTIFICATION_TOPIC_ARN: !Ref TradingNotificationsTopic
          PERFORMANCE_REPORTS_BUCKET: !Ref PerformanceReportsBucket
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # Per-trade execution configuration (for run aggregation)
          ENABLE_PER_TRADE_EXECUTION: !Ref EnablePerTradeExecution
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
      Events:
        TradeExecutedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.execution"
              detail-type:
                - "TradeExecuted"
        # Route WorkflowFailed from ANY alchemiser source to notifications
        # Each Lambda (strategy, portfolio, execution) publishes WorkflowFailed with its own source
        WorkflowFailedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - prefix: "alchemiser."
              detail-type:
                - "WorkflowFailed"
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  NotificationsExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: NotificationsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Ref TradingNotificationsTopic
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:GetItem
                  - dynamodb:Scan
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  - !Sub "${PerformanceReportsBucket.Arn}/*"
              # Per-trade execution: Execution runs table access (for run aggregation)
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn

  # ========== METRICS LAMBDA (PRODUCTION ONLY) ==========
  # Publishes per-strategy realized P&L metrics to CloudWatch for dashboard visualization
  MetricsFunction:
    Type: AWS::Serverless::Function
    Condition: IsProduction
    Properties:
      FunctionName: !Sub "alchemiser-${Stage}-metrics"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.metrics_v2.lambda_handler.lambda_handler
      Role: !GetAtt MetricsExecutionRole.Arn
      Layers:
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog, boto3)
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          STAGE: !Ref Stage
      Events:
        TradeExecutedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.execution"
              detail-type:
                - "TradeExecuted"
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  MetricsExecutionRole:
    Type: AWS::IAM::Role
    Condition: IsProduction
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: MetricsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:GetItem
                  - dynamodb:Scan
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: "*"

  # Scheduler to trigger Strategy (workflow entry point)
  # When EnableMultiNodeStrategy=true, triggers Orchestrator (fan-out/fan-in)
  # When EnableMultiNodeStrategy=false, triggers Strategy directly (legacy mode)
  StrategySchedule:
    Type: AWS::Scheduler::Schedule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-schedule"
        - !Sub "alchemiser-${Stage}-strategy-schedule"
      Description: !If
        - EnableMultiNode
        - "Execute trading strategy (multi-node mode) daily at 9:35 AM New York time"
        - "Execute trading strategy (legacy mode) daily at 9:35 AM New York time"
      ScheduleExpression: "cron(35 9 ? * MON-FRI *)"
      ScheduleExpressionTimezone: "America/New_York"
      FlexibleTimeWindow:
        Mode: "OFF"
      Target:
        Arn: !If
          - EnableMultiNode
          - !GetAtt StrategyOrchestratorFunction.Arn
          - !GetAtt StrategyFunction.Arn
        RoleArn: !GetAtt StrategySchedulerRole.Arn
        Input: '{"mode": "trade"}'
        RetryPolicy:
          MaximumRetryAttempts: 1

  StrategySchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: scheduler.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeStrategy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt StrategyFunction.Arn
                  - !GetAtt StrategyOrchestratorFunction.Arn

  # ========== DATA LAMBDA ==========
  # Fetches historical market data from Alpaca and stores in S3 as Parquet
  # Runs nightly after market close to refresh data for all strategy symbols
  DataFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-data"
        - !Sub "alchemiser-${Stage}-data"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: ./
      Handler: the_alchemiser.data_v2.lambda_handler.lambda_handler
      Role: !GetAtt DataExecutionRole.Arn
      Layers:
        - !Ref DataLayer  # awswrangler + alpaca-py (built via Makefile)
      Timeout: 900  # 15 minutes max for full data
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          MARKET_DATA_BUCKET: !Ref MarketDataBucket
          ALPACA__KEY: !If [ IsDev, !Ref AlpacaKey, !Ref ProdAlpacaKey ]
          ALPACA__SECRET: !If [ IsDev, !Ref AlpacaSecret, !Ref ProdAlpacaSecret ]
          ALPACA__ENDPOINT: !If [ IsDev, !Ref AlpacaEndpoint, !Ref ProdAlpacaEndpoint ]
    Metadata:
      BuildMethod: python3.12
      BuildProperties:
        Include:
          - 'the_alchemiser/**/*.py'
          - 'the_alchemiser/**/*.clj'
          - 'the_alchemiser/config/*.json'
          - 'the_alchemiser/py.typed'
        Exclude:
          - '.env*'
          - 'the_alchemiser/.env*'
          - '**/__pycache__/**'
          - '**/*.pyc'
          - '**/*.pyo'
          - '**/*.egg-info/**'
          - 'the_alchemiser/.editorconfig'
          - 'the_alchemiser/**/*.md'

  DataExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DataPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:ListBucket
                Resource:
                  - !GetAtt MarketDataBucket.Arn
                  - !Sub "${MarketDataBucket.Arn}/*"

  # Scheduler to trigger Data (nightly after market close + data lag)
  DataSchedule:
    Type: AWS::Scheduler::Schedule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-data-schedule"
        - !Sub "alchemiser-${Stage}-data-schedule"
      Description: "Refresh market data daily at 4 AM UTC / 11 PM ET (Mon-Fri)"
      ScheduleExpression: "cron(0 4 ? * TUE-SAT *)"  # Runs Tue-Sat to catch Mon-Fri data
      ScheduleExpressionTimezone: "UTC"
      FlexibleTimeWindow:
        Mode: "OFF"
      Target:
        Arn: !GetAtt DataFunction.Arn
        RoleArn: !GetAtt DataSchedulerRole.Arn
        Input: '{}'
        RetryPolicy:
          MaximumRetryAttempts: 2

  DataSchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: scheduler.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeData
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt DataFunction.Arn

  # ============================================================================
  # END MICROSERVICES ARCHITECTURE
  # ============================================================================

  # ============================================================================
  # OBSERVABILITY: CloudWatch Logs Insights & Dashboard
  # ============================================================================
  
  # CloudWatch Dashboard for at-a-glance monitoring
  # Note: Log groups are auto-created by Lambda; we reference them by name
  AlchemiserDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-monitoring"
        - !Sub "alchemiser-${Stage}-monitoring"
      DashboardBody: !Sub
        - |
          {
            "widgets": [
              {
                "type": "log",
                "properties": {
                  "title": "Latest Errors & Warnings (All Lambdas)",
                  "region": "${AWS::Region}",
                  "query": "SOURCE '${StrategyLog}'\n| SOURCE '${OrchestratorLog}'\n| SOURCE '${AggregatorLog}'\n| SOURCE '${PortfolioLog}'\n| SOURCE '${ExecutionLog}'\n| SOURCE '${NotificationsLog}'\n| SOURCE '${MetricsLog}'\n| SOURCE '${DataLog}'\n| fields @timestamp, @log, level, event, module, correlation_id, message\n| filter level in ['error', 'warn', 'warning']\n| sort @timestamp desc\n| limit 50"
                },
                "x": 0,
                "y": 0,
                "width": 24,
                "height": 8
              },
              {
                "type": "log",
                "properties": {
                  "title": "Errors by Correlation ID (Trace Workflow Runs)",
                  "region": "${AWS::Region}",
                  "query": "SOURCE '${StrategyLog}'\n| SOURCE '${OrchestratorLog}'\n| SOURCE '${AggregatorLog}'\n| SOURCE '${PortfolioLog}'\n| SOURCE '${ExecutionLog}'\n| SOURCE '${NotificationsLog}'\n| SOURCE '${MetricsLog}'\n| SOURCE '${DataLog}'\n| fields @timestamp, @log, level, event, module, correlation_id, message\n| filter level = 'error'\n| sort @timestamp desc\n| limit 100"
                },
                "x": 0,
                "y": 8,
                "width": 24,
                "height": 8
              },
              {
                "type": "log",
                "properties": {
                  "title": "Recent Workflow Runs (by correlation_id)",
                  "region": "${AWS::Region}",
                  "query": "SOURCE '${StrategyLog}'\n| SOURCE '${OrchestratorLog}'\n| SOURCE '${AggregatorLog}'\n| SOURCE '${PortfolioLog}'\n| SOURCE '${ExecutionLog}'\n| SOURCE '${NotificationsLog}'\n| SOURCE '${MetricsLog}'\n| SOURCE '${DataLog}'\n| fields @timestamp, @log, level, event, correlation_id, module\n| filter event like /SignalGenerated|PartialSignalGenerated|RebalancePlanned|TradeExecuted|WorkflowCompleted|WorkflowFailed/\n| sort @timestamp desc\n| limit 50"
                },
                "x": 0,
                "y": 16,
                "width": 24,
                "height": 8
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Realized P&L by Strategy (Last 30 Days)",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 86400,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "RealizedPnL", { "stat": "Sum" } ]
                  ],
                  "yAxis": {
                    "left": {
                      "label": "P&L ($)"
                    }
                  },
                  "view": "timeSeries",
                  "stacked": false
                },
                "x": 0,
                "y": 24,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Cumulative Realized P&L (All Strategies)",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 2592000,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "RealizedPnL", { "stat": "Sum" } ]
                  ],
                  "view": "singleValue"
                },
                "x": 12,
                "y": 24,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Trade Count (Last 7 Days)",
                  "region": "${AWS::Region}",
                  "stat": "SampleCount",
                  "period": 86400,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "RealizedPnL", { "stat": "SampleCount" } ]
                  ],
                  "yAxis": {
                    "left": {
                      "label": "Trades"
                    }
                  },
                  "view": "timeSeries",
                  "stacked": false
                },
                "x": 18,
                "y": 24,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Capital Deployed (Last 7 Days)",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 86400,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "CapitalDeployedPct", { "stat": "Average" } ]
                  ],
                  "yAxis": {
                    "left": {
                      "label": "%",
                      "min": 0,
                      "max": 100
                    }
                  },
                  "view": "timeSeries",
                  "stacked": false
                },
                "x": 0,
                "y": 30,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Current Capital Deployed",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 300,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "CapitalDeployedPct", { "stat": "Average" } ]
                  ],
                  "view": "singleValue"
                },
                "x": 12,
                "y": 30,
                "width": 6,
                "height": 6
              }
            ]
          }
        - StrategyLog: !Sub "/aws/lambda/${StrategyFunction}"
          OrchestratorLog: !Sub "/aws/lambda/${StrategyOrchestratorFunction}"
          AggregatorLog: !Sub "/aws/lambda/${StrategyAggregatorFunction}"
          PortfolioLog: !Sub "/aws/lambda/${PortfolioFunction}"
          ExecutionLog: !Sub "/aws/lambda/${ExecutionFunction}"
          NotificationsLog: !Sub "/aws/lambda/${NotificationsFunction}"
          MetricsLog: !Sub "/aws/lambda/${MetricsFunction}"
          DataLog: !Sub "/aws/lambda/${DataFunction}"
          StageTitle: !FindInMap [StageConfig, !Ref Stage, TitleCase]

Outputs:
  TradeLedgerTableName:
    Description: "DynamoDB table for trade ledger persistence"
    Value: !Ref TradeLedgerTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-TradeLedgerTable"
        - !Sub "alchemiser-${Stage}-TradeLedgerTable"

  AggregationSessionsTableName:
    Description: "DynamoDB table for multi-node strategy aggregation sessions"
    Value: !Ref AggregationSessionsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-AggregationSessionsTable"
        - !Sub "alchemiser-${Stage}-AggregationSessionsTable"

  ExecutionRunsTableName:
    Description: "DynamoDB table for per-trade execution run tracking"
    Value: !Ref ExecutionRunsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-ExecutionRunsTable"
        - !Sub "alchemiser-${Stage}-ExecutionRunsTable"

  RebalancePlanTableName:
    Description: "DynamoDB table for rebalance plan auditability (90-day TTL)"
    Value: !Ref RebalancePlanTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-RebalancePlanTable"
        - !Sub "alchemiser-${Stage}-RebalancePlanTable"

  ExecutionFifoQueueUrl:
    Description: "SQS FIFO queue for per-trade execution"
    Value: !Ref ExecutionFifoQueue
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-ExecutionFifoQueue"
        - !Sub "alchemiser-${Stage}-ExecutionFifoQueue"

  PerformanceReportsBucketName:
    Description: "S3 bucket for strategy performance CSV reports"
    Value: !Ref PerformanceReportsBucket
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-PerformanceReportsBucket"
        - !Sub "alchemiser-${Stage}-PerformanceReportsBucket"

  MarketDataBucketName:
    Description: "S3 bucket for historical market data (Parquet files)"
    Value: !Ref MarketDataBucket
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-MarketDataBucket"
        - !Sub "alchemiser-${Stage}-MarketDataBucket"

  DeploymentStage:
    Description: "Deployed stage"
    Value: !Ref Stage
  
  StackNameUsed:
    Description: "Stack name used for resource naming"
    Value: !If [ HasStackName, !Ref StackName, !Sub "alchemiser-${Stage}" ]


  DashboardURL:
    Description: "CloudWatch Dashboard for monitoring errors and warnings"
    Value: !Sub "https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${AlchemiserDashboard}"

  LogsInsightsURL:
    Description: "CloudWatch Logs Insights for querying logs across all Lambdas"
    Value: !Sub "https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#logsV2:logs-insights"

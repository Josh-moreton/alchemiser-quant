# yaml-language-server: $schema=https://raw.githubusercontent.com/aws/serverless-application-model/main/samtranslator/validator/sam_schema/schema.json
# yaml-language-server: disable-validation
AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: >
  The Alchemiser Quantitative Trading System

  Multi-strategy algorithmic trading engine deployed as an AWS Lambda Function

Parameters:
  Stage:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - staging
      - prod
      - ephemeral
    Description: Deployment stage (dev, staging, prod, or ephemeral)
  
  StackName:
    Type: String
    Default: ""
    Description: Optional override for stack-specific resource naming (used for ephemeral stacks)
  
  Env:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - staging
      - prod
      - ephemeral
    Description: Environment type for resource configuration
  
  ArtifactPrefix:
    Type: String
    Default: ""
    Description: S3 prefix for artifacts (used for ephemeral stack isolation)

  AlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key (used only in dev; leave blank for prod)

  AlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret (used only in dev; leave blank for prod)

  AlpacaEndpoint:
    Type: String
    Default: https://paper-api.alpaca.markets/v2
    Description: Alpaca API endpoint; defaults to paper for dev, live is used for prod

  # Margin/Leverage configuration
  EquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: ALPACA__EQUITY_DEPLOYMENT_PCT - percentage of equity to deploy (1.0=100%, 1.10=110% with margin)

  ProdEquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: Equity deployment percentage for production (conservative default)

  # Staging-only parameters (only used when Stage=staging)
  StagingAlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key for staging (required when Stage=staging)

  StagingAlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret for staging (required when Stage=staging)

  StagingAlpacaEndpoint:
    Type: String
    Default: https://paper-api.alpaca.markets/v2
    Description: Alpaca API endpoint for staging (typically paper trading)

  StagingEquityDeploymentPct:
    Type: String
    Default: "1.0"
    Description: Equity deployment percentage for staging

  # Production-only parameters (only used when Stage=prod)
  ProdAlpacaKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Key for production (required when Stage=prod)

  ProdAlpacaSecret:
    Type: String
    Default: ""
    NoEcho: true
    Description: Alpaca API Secret for production (required when Stage=prod)

  ProdAlpacaEndpoint:
    Type: String
    Default: https://api.alpaca.markets
    Description: Alpaca API endpoint for production

  # Data Function Configuration
  DataRefreshScheduleDev:
    Type: String
    Default: "cron(0 9 ? * TUE-SAT *)"
    Description: Data refresh schedule for dev (9 AM UTC, Tue-Sat = 10 AM UK morning)

  DataRefreshScheduleStaging:
    Type: String
    Default: "cron(30 9 ? * TUE-SAT *)"
    Description: Data refresh schedule for staging (9:30 AM UTC, Tue-Sat = 10:30 AM UK morning)

  DataRefreshScheduleProd:
    Type: String
    Default: "cron(0 10 ? * TUE-SAT *)"
    Description: Data refresh schedule for prod (10 AM UTC, Tue-Sat = 11 AM UK morning)

  FetchCooldownMinutes:
    Type: Number
    Default: 15
    Description: Cooldown period (minutes) before allowing another fetch for same symbol

  # Strategy configuration: now defined in code defaults. Override via env only if required.

Mappings:
  StageConfig:
    dev:
      TitleCase: "Dev"
    staging:
      TitleCase: "Staging"
    prod:
      TitleCase: "Production"
    ephemeral:
      TitleCase: "Ephemeral"

Conditions:
  IsDev: !Equals [ !Ref Stage, dev ]
  IsStaging: !Equals [ !Ref Stage, staging ]
  IsProduction: !Equals [ !Ref Stage, prod ]
  IsNotProduction: !Not [ !Equals [ !Ref Stage, prod ] ]
  IsEphemeral: !Equals [ !Ref Stage, ephemeral ]
  HasStackName: !Not [ !Equals [ !Ref StackName, "" ] ]
  UseStackNameForResources: !Or [ !Condition IsEphemeral, !Condition HasStackName ]

Globals:
  Function:
    Timeout: 900 # 15 minutes - max for Lambda
    MemorySize: 512
    Environment:
      Variables:
        # Stage awareness for code-level profiles
        APP__STAGE: !If [ IsProduction, "prod", !If [ IsStaging, "staging", "dev" ] ]
        # Alpaca Configuration
        ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
        ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
        ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
        # Strategy DSL configuration now comes from code defaults; override via env only if necessary
        # STRATEGY__DSL_FILES: '["1-KMLM.clj","2-Nuclear.clj","5-Coin.clj","6-TQQQ-FLT.clj"]'
        # STRATEGY__DSL_ALLOCATIONS: '{"1-KMLM.clj":0.4,"2-Nuclear.clj":0.25,"5-Coin.clj":0.1,"6-TQQQ-FLT.clj":0.25}'

        # Margin/Leverage configuration - controls how much of equity to deploy
        # 1.0 = 100% of equity (no margin), 1.10 = 110% (10% margin usage)
        ALPACA__EQUITY_DEPLOYMENT_PCT: !If [ IsProduction, !Ref ProdEquityDeploymentPct, !If [ IsStaging, !Ref StagingEquityDeploymentPct, !Ref EquityDeploymentPct ] ]

        # Trade ledger DynamoDB table
        TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable

  # Strategy configuration now packaged with code; env overrides optional

  # (no additional Globals keys)

Resources:
  # DynamoDB Table for trade ledger persistence
  TradeLedgerTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-trade-ledger"
        - !Sub "alchemiser-${Stage}-trade-ledger"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
        - AttributeName: GSI1PK
          AttributeType: S
        - AttributeName: GSI1SK
          AttributeType: S
        - AttributeName: GSI2PK
          AttributeType: S
        - AttributeName: GSI2SK
          AttributeType: S
        - AttributeName: GSI3PK
          AttributeType: S
        - AttributeName: GSI3SK
          AttributeType: S
        - AttributeName: GSI4PK
          AttributeType: S
        - AttributeName: GSI4SK
          AttributeType: S
        - AttributeName: GSI5PK
          AttributeType: S
        - AttributeName: GSI5SK
          AttributeType: S
        - AttributeName: GSI6PK
          AttributeType: S
        - AttributeName: GSI6SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      GlobalSecondaryIndexes:
        # GSI1: Query by correlation_id
        - IndexName: GSI1-CorrelationIndex
          KeySchema:
            - AttributeName: GSI1PK
              KeyType: HASH
            - AttributeName: GSI1SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI2: Query by symbol
        - IndexName: GSI2-SymbolIndex
          KeySchema:
            - AttributeName: GSI2PK
              KeyType: HASH
            - AttributeName: GSI2SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI3: Query by strategy
        - IndexName: GSI3-StrategyIndex
          KeySchema:
            - AttributeName: GSI3PK
              KeyType: HASH
            - AttributeName: GSI3SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI4: Query snapshots by correlation_id
        - IndexName: GSI4-CorrelationSnapshotIndex
          KeySchema:
            - AttributeName: GSI4PK
              KeyType: HASH
            - AttributeName: GSI4SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI5: Query strategy lots by strategy name (for FIFO P&L tracking)
        - IndexName: GSI5-StrategyLotsIndex
          KeySchema:
            - AttributeName: GSI5PK
              KeyType: HASH
            - AttributeName: GSI5SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        
        # GSI6: Query strategy lots by symbol (cross-strategy position analysis)
        - IndexName: GSI6-SymbolLotsIndex
          KeySchema:
            - AttributeName: GSI6PK
              KeyType: HASH
            - AttributeName: GSI6SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      
      SSESpecification:
        SSEEnabled: true
        # Use AWS-managed encryption (not KMS) to avoid requiring additional IAM permissions
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: trade-ledger

  # ========== AGGREGATION SESSIONS TABLE (MULTI-NODE SCALING) ==========
  # DynamoDB Table for tracking multi-node strategy aggregation sessions
  AggregationSessionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-aggregation-sessions"
        - !Sub "alchemiser-${Stage}-aggregation-sessions"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: aggregation-sessions

  # ========== EXECUTION RUNS TABLE (PER-TRADE SCALING) ==========
  # DynamoDB Table for tracking per-trade execution run state
  # Follows same pattern as AggregationSessionsTable for Strategy multi-node
  ExecutionRunsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-execution-runs"
        - !Sub "alchemiser-${Stage}-execution-runs"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: execution-runs

  # ========== REBALANCE PLAN TABLE (AUDITABILITY) ==========
  # DynamoDB Table for persisting RebalancePlan documents with 90-day TTL
  # Enables "why didn't we trade X?" queries beyond EventBridge's 24-hour retention
  RebalancePlanTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - UseStackNameForResources
        - !Sub "${StackName}-rebalance-plans"
        - !Sub "alchemiser-${Stage}-rebalance-plans"
      BillingMode: PAY_PER_REQUEST
      
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
        - AttributeName: GSI1PK
          AttributeType: S
        - AttributeName: GSI1SK
          AttributeType: S
      
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      
      GlobalSecondaryIndexes:
        # GSI1: Query by correlation_id for tracing workflow decisions
        - IndexName: GSI1-CorrelationIndex
          KeySchema:
            - AttributeName: GSI1PK
              KeyType: HASH
            - AttributeName: GSI1SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      
      SSESpecification:
        SSEEnabled: true
      
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: rebalance-plans

  # ========== MARKET DATA FETCH REQUESTS TABLE (PER-STAGE) ==========
  # DynamoDB table for deduplicating concurrent fetch requests from Data Lambda
  # Prevents multiple fetch attempts when data is detected as missing/stale
  MarketDataFetchRequestsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-market-data-fetch-requests"
        - !Sub "alchemiser-${Stage}-market-data-fetch-requests"
      BillingMode: PAY_PER_REQUEST

      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S

      KeySchema:
        - AttributeName: PK
          KeyType: HASH

      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true

      SSESpecification:
        SSEEnabled: true

      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: market-data-fetch-requests

  # ========== BAD DATA MARKERS TABLE (PER-STAGE) ==========
  # DynamoDB table for tracking symbols/dates needing data re-fetch
  # Populated by data quality validation, consumed by Data Lambda on next refresh
  BadDataMarkersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-bad-data-markers"
        - !Sub "alchemiser-${Stage}-bad-data-markers"
      BillingMode: PAY_PER_REQUEST

      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S

      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE

      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true

      SSESpecification:
        SSEEnabled: true

      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: bad-data-markers

  # ========== STRATEGY WEIGHTS TABLE (PER-STAGE) ==========
  # DynamoDB table for storing live strategy weights with Calmar-tilted adjustments
  # Base weights come from strategy.prod.json, live weights adjusted monthly via Calmar ratio
  StrategyWeightsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-weights"
        - !Sub "alchemiser-${Stage}-strategy-weights"
      BillingMode: PAY_PER_REQUEST

      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
        - AttributeName: GSI1PK
          AttributeType: S
        - AttributeName: GSI1SK
          AttributeType: S

      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE

      GlobalSecondaryIndexes:
        # GSI1: Query by version for historical tracking
        - IndexName: GSI1-VersionIndex
          KeySchema:
            - AttributeName: GSI1PK
              KeyType: HASH
            - AttributeName: GSI1SK
              KeyType: RANGE
          Projection:
            ProjectionType: ALL

      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true

      SSESpecification:
        SSEEnabled: true

      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: strategy-weights

  # ========== FUNCTION-SPECIFIC LAMBDA LAYERS ==========
  # Each Lambda gets its own optimized layer with only required dependencies
  # boto3/botocore excluded from all layers - Lambda runtime provides them

  # Strategy Layer: awswrangler (pandas, numpy, pyarrow) + alpaca-py
  # Built via Makefile: downloads pre-built awswrangler, adds alpaca-py
  StrategyLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-deps"
        - !Sub "alchemiser-${Stage}-strategy-deps"
      Description: awswrangler 3.10.0 + alpaca-py (pandas, numpy, pyarrow included)
      ContentUri: layers/strategy/
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - x86_64
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: makefile

  # Portfolio Layer: alpaca-py + pydantic (no pandas/numpy)
  PortfolioLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-portfolio-deps"
        - !Sub "alchemiser-${Stage}-portfolio-deps"
      Description: Portfolio Lambda dependencies (alpaca-py, pydantic)
      ContentUri: layers/portfolio/
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # Execution Layer: alpaca-py + pydantic (no pandas/numpy)
  ExecutionLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-deps"
        - !Sub "alchemiser-${Stage}-execution-deps"
      Description: Execution Lambda dependencies (alpaca-py, pydantic)
      ContentUri: layers/execution/
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # Notifications Layer: pydantic + structlog + alpaca-py (lightweight)
  NotificationsLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-notifications-deps"
        - !Sub "alchemiser-${Stage}-notifications-deps"
      Description: Notifications Lambda dependencies (pydantic, structlog, alpaca-py)
      ContentUri: layers/notifications/
      CompatibleRuntimes:
        - python3.12
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # Data Layer: awswrangler (pandas, numpy, pyarrow) + alpaca-py
  # Built via Makefile: downloads pre-built awswrangler, adds alpaca-py
  # Total size: ~186MB unzipped (under 250MB limit)
  DataLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-data-deps"
        - !Sub "alchemiser-${Stage}-data-deps"
      Description: awswrangler 3.10.0 + alpaca-py (pandas, numpy, pyarrow included)
      ContentUri: layers/data/
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - x86_64
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: makefile

  # ========== SHARED CODE LAMBDA LAYER ==========
  # Contains the_alchemiser.shared module - used by ALL Lambda functions
  SharedCodeLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-shared-code"
        - !Sub "alchemiser-${Stage}-shared-code"
      Description: Shared business logic (the_alchemiser.shared module)
      ContentUri: layers/shared/
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - x86_64
      RetentionPolicy: Retain
    Metadata:
      BuildMethod: python3.12

  # ============================================================================
  # MICROSERVICES ARCHITECTURE
  # ============================================================================

  # EventBridge Event Bus for async domain event communication
  AlchemiserEventBus:
    Type: AWS::Events::EventBus
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-events"
        - !Sub "alchemiser-${Stage}-events"

  # SQS Queue for reliable trade execution with DLQ
  ExecutionQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-queue"
        - !Sub "alchemiser-${Stage}-execution-queue"
      VisibilityTimeout: 900  # 15 mins for execution
      MessageRetentionPeriod: 345600  # 4 days
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ExecutionDLQ.Arn
        maxReceiveCount: 3

  ExecutionDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-dlq"
        - !Sub "alchemiser-${Stage}-execution-dlq"
      MessageRetentionPeriod: 1209600  # 14 days

  # SQS FIFO Queue for parallel per-trade execution with exactly-once processing
  # FIFO queue with perMessageGroupId throughput enables parallel Lambda invocations
  # MessageGroupId=symbol allows parallel execution across different symbols
  # MessageDeduplicationId=trade_id prevents duplicate execution (fixes Dec 19 incident)
  # SELLâ†’BUY ordering is controlled via two-phase enqueue in Portfolio Lambda
  ExecutionFifoQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution.fifo"
        - !Sub "alchemiser-${Stage}-execution.fifo"
      FifoQueue: true
      ContentBasedDeduplication: false  # Use explicit MessageDeduplicationId
      DeduplicationScope: messageGroup  # Dedup only within same symbol
      FifoThroughputLimit: perMessageGroupId  # High throughput: parallel across symbols
      VisibilityTimeout: 900  # 15 mins for execution
      MessageRetentionPeriod: 345600  # 4 days
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ExecutionFifoDLQ.Arn
        maxReceiveCount: 3

  ExecutionFifoDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution-dlq.fifo"
        - !Sub "alchemiser-${Stage}-execution-dlq.fifo"
      FifoQueue: true
      MessageRetentionPeriod: 1209600  # 14 days

  # SNS Topic for DLQ alerts (very low cost: ~$0.50/million messages)
  DLQAlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-dlq-alerts"
        - !Sub "alchemiser-${Stage}-dlq-alerts"
      DisplayName: "Alchemiser DLQ Alert"

  # Email subscription for DLQ alerts
  DLQAlertEmailSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref DLQAlertTopic
      Protocol: email
      Endpoint: notifications@rwxt.org

  # ========== PERFORMANCE REPORTS S3 BUCKET ==========
  # S3 bucket for strategy performance CSV reports with presigned URL access
  PerformanceReportsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !If
        - HasStackName
        - !Sub "${StackName}-performance-reports"
        - !Sub "alchemiser-${Stage}-reports"
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldReports
            ExpirationInDays: 30
            Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: performance-reports

  # ========== MARKET DATA S3 BUCKET (PER-STAGE) ==========
  # Per-stage S3 buckets for market data isolation (dev, staging, prod each get own bucket)
  # Replaces previous shared bucket architecture (alchemiser-shared-market-data)
  MarketDataBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      BucketName: !If
        - HasStackName
        - !Sub "${StackName}-market-data"
        - !Sub "alchemiser-${Stage}-market-data"
      VersioningConfiguration:
        Status: Enabled
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldVersions
            Status: Enabled
            NoncurrentVersionExpiration:
              NoncurrentDays: 30
      Tags:
        - Key: Environment
          Value: !Ref Stage
        - Key: Service
          Value: market-data

  # ========== TRADING NOTIFICATIONS SNS ==========
  # SNS Topic for trading notifications (trade results, workflow failures)
  TradingNotificationsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-trading-notifications"
        - !Sub "alchemiser-${Stage}-trading-notifications"
      DisplayName: "Alchemiser Trading Notifications"

  # Email subscription for trading notifications
  TradingNotificationsEmailSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref TradingNotificationsTopic
      Protocol: email
      Endpoint: notifications@rwxt.org

  # CloudWatch Alarm for DLQ messages (triggers when messages hit DLQ)
  DLQMessageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-dlq-messages"
        - !Sub "alchemiser-${Stage}-dlq-messages"
      AlarmDescription: "Alert when messages land in the execution DLQ after 3 failed attempts"
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: QueueName
          Value: !GetAtt ExecutionDLQ.QueueName
      AlarmActions:
        - !Ref DLQAlertTopic
      TreatMissingData: notBreaching

  # CloudWatch Alarm for parallel execution DLQ messages (per-trade execution failures)
  FifoDLQMessageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-parallel-dlq-messages"
        - !Sub "alchemiser-${Stage}-parallel-dlq-messages"
      AlarmDescription: "Alert when per-trade execution messages hit parallel DLQ after 3 retries"
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: QueueName
          Value: !GetAtt ExecutionFifoDLQ.QueueName
      AlarmActions:
        - !Ref DLQAlertTopic
      TreatMissingData: notBreaching

  # CloudWatch Alarm for stuck execution runs (RUNNING > 30 mins)
  # Detects orphaned runs where trades never completed
  StuckRunsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-stuck-execution-runs"
        - !Sub "alchemiser-${Stage}-stuck-execution-runs"
      AlarmDescription: "Alert when execution runs are stuck in RUNNING state for >30 minutes"
      MetricName: StuckRuns
      Namespace: Alchemiser/Execution
      Statistic: Maximum
      Period: 300  # 5 minutes
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: TableName
          Value: !Ref ExecutionRunsTable
      AlarmActions:
        - !Ref DLQAlertTopic
      TreatMissingData: notBreaching

  # Note: ExecutionQueuePolicy removed - EventBridge no longer routes to SQS.
  # Portfolio handler sends TradeMessage objects directly to SQS via SDK.

  # EventBridge Rules for event routing
  SignalGeneratedRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-signal-generated"
        - !Sub "alchemiser-${Stage}-signal-generated"
      EventBusName: !Ref AlchemiserEventBus
      EventPattern:
        source:
          - alchemiser.strategy
        detail-type:
          - SignalGenerated
      Targets:
        - Id: PortfolioTarget
          Arn: !GetAtt PortfolioFunction.Arn

  SignalGeneratedPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PortfolioFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt SignalGeneratedRule.Arn

  # ========== EVENTBRIDGE PERMISSIONS FOR LAMBDAS ==========
  # SAM's Events: property creates the EventBridge rule but NOT the Lambda permission.
  # These permissions grant EventBridge service permission to invoke the Lambdas.
  # Without these, EventBridge silently drops events after matching the rule.

  # Permission for TradeAggregator to be invoked by EventBridge on TradeExecuted events
  TradeAggregatorEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TradeAggregatorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AlchemiserEventBus.Name}/*"

  # Permission for Notifications Lambda to be invoked by EventBridge
  # Allows both AllTradesCompleted (from TradeAggregator) and WorkflowFailed (from any Lambda)
  NotificationsEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref NotificationsFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AlchemiserEventBus.Name}/*"

  # Permission for StrategyAggregator Lambda to be invoked by EventBridge on PartialSignalGenerated events
  StrategyAggregatorEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref StrategyAggregatorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AlchemiserEventBus.Name}/*"

  # Permission for Metrics Lambda to be invoked by EventBridge on TradeExecuted events
  MetricsEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref MetricsFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AlchemiserEventBus.Name}/*"

  # Note: RebalancePlannedRule removed - Portfolio handler sends TradeMessage
  # objects directly to SQS. The RebalancePlanned event published to EventBridge
  # is for observability only (CloudWatch Logs Insights queries).

  # Strategy Worker Lambda - Executes strategy DSL files (invoked by orchestrator or directly)
  StrategyFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-worker"
        - !Sub "alchemiser-${Stage}-strategy-worker"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/strategy_worker/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt StrategyExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer
        - !Ref StrategyLayer  # awswrangler + alpaca-py (built via Makefile)
      Timeout: 900  # Max timeout for on-demand data fetching
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          MARKET_DATA_BUCKET: !Ref MarketDataBucket
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # On-demand data fetching: sync refresh invokes Data Lambda when S3 cache is empty
          DATA_FUNCTION_NAME: !Ref DataFunction
          STAGE: !Ref Stage
          # Sync refresh timeout: max wait for Data Lambda to fetch missing data (5 minutes)
          SYNC_REFRESH_TIMEOUT_SECONDS: "300"
          # Enable live bar injection - appends today's current price to historical data
          # This allows indicators (e.g., 200-day SMA) to use the most recent price

    Metadata:
      BuildMethod: python3.12

  StrategyExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              # S3 permissions for per-stage market data bucket (read-only)
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !GetAtt MarketDataBucket.Arn
                  - !Sub "${MarketDataBucket.Arn}/*"
              # Lambda invoke permission for sync refresh (on-demand data fetching)
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt DataFunction.Arn

  # ========== MULTI-NODE STRATEGY SCALING (Orchestrator + Aggregator) ==========
  # These Lambdas enable horizontal scaling of strategy execution by running
  # each DSL file in a separate Lambda invocation and aggregating the results.

  # Strategy Orchestrator Lambda - Entry point that dispatches parallel strategy execution
  StrategyOrchestratorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-strategy-orchestrator"
        - !Sub "alchemiser-${Stage}-strategy-orchestrator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/strategy_orchestrator/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt StrategyOrchestratorExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog)
      Timeout: 60  # Orchestrator just dispatches, doesn't run strategies
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          AGGREGATION_TABLE_NAME: !Ref AggregationSessionsTable
          STRATEGY_FUNCTION_NAME: !Ref StrategyFunction
          AGGREGATION_TIMEOUT_SECONDS: "600"
          STRATEGY_WEIGHTS_TABLE_NAME: !Ref StrategyWeightsTable
    Metadata:
      BuildMethod: python3.12

  StrategyOrchestratorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyOrchestratorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt AggregationSessionsTable.Arn
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt StrategyWeightsTable.Arn
                  - !Sub "${StrategyWeightsTable.Arn}/index/*"
              # Permission to invoke Strategy Lambda for each file
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                  - lambda:InvokeAsync
                Resource:
                  - !GetAtt StrategyFunction.Arn

  # Signal Aggregator Lambda - Aggregates partial strategy signals into consolidated portfolio
  StrategyAggregatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-signal-aggregator"
        - !Sub "alchemiser-${Stage}-signal-aggregator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/strategy_aggregator/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt StrategyAggregatorExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog)
      Timeout: 60  # Aggregation should be fast
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          AGGREGATION_TABLE_NAME: !Ref AggregationSessionsTable
          ALLOCATION_TOLERANCE: "0.01"
      Events:
        PartialSignalEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.strategy"
              detail-type:
                - "PartialSignalGenerated"
    Metadata:
      BuildMethod: python3.12

  StrategyAggregatorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: StrategyAggregatorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt AggregationSessionsTable.Arn

  # ========== END MULTI-NODE STRATEGY SCALING ==========

  # Portfolio Lambda - Rebalance planning microservice
  PortfolioFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-portfolio"
        - !Sub "alchemiser-${Stage}-portfolio"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/portfolio/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt PortfolioExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer
        - !Ref PortfolioLayer
      Timeout: 900  # Max timeout for comprehensive processing
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # Rebalance plan persistence for auditability
          REBALANCE_PLAN__TABLE_NAME: !Ref RebalancePlanTable
          # Per-trade execution configuration
          EXECUTION_FIFO_QUEUE_URL: !Ref ExecutionFifoQueue
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
    Metadata:
      BuildMethod: python3.12

  PortfolioExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: PortfolioPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              # Per-trade parallel execution: SQS Standard queue access (named *Fifo for AWS compatibility)
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:GetQueueAttributes
                Resource:
                  - !GetAtt ExecutionFifoQueue.Arn
              # Per-trade execution: Execution runs table access
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn
              # Rebalance plan persistence for auditability
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt RebalancePlanTable.Arn
                  - !Sub "${RebalancePlanTable.Arn}/index/*"

  # Execution Lambda - Trade execution microservice (triggered via SQS)
  ExecutionFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-execution"
        - !Sub "alchemiser-${Stage}-execution"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/execution/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt ExecutionExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer
        - !Ref ExecutionLayer
      Timeout: 600
      MemorySize: 1024
      # Concurrency limited to 10 for Alpaca trading API rate limits (200 calls/min)
      # WebSocket handles order status updates, so each trade only makes ~1-2 REST calls
      # 10 concurrent = ~2-4 calls/sec (well under 3.33/sec limit)
      ReservedConcurrentExecutions: 10
      # WebSocket connections are cleaned up after each execution via cleanup_all_instances()
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # Per-trade execution configuration
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
          # Queue URL for triggering BUY phase after SELL phase completes
          EXECUTION_FIFO_QUEUE_URL: !Ref ExecutionFifoQueue
      Events:
        ExecutionQueue:
          Type: SQS
          Properties:
            Queue: !GetAtt ExecutionQueue.Arn
            BatchSize: 1
            FunctionResponseTypes:
              - ReportBatchItemFailures
        # Per-trade parallel execution: Standard queue (resource named *Fifo for AWS compatibility)
        ExecutionFifoQueue:
          Type: SQS
          Properties:
            Queue: !GetAtt ExecutionFifoQueue.Arn
            BatchSize: 1
            FunctionResponseTypes:
              - ReportBatchItemFailures
    Metadata:
      BuildMethod: python3.12

  ExecutionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ExecutionPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sqs:SendMessage  # For triggering BUY phase after SELL phase completes
                Resource:
                  - !GetAtt ExecutionQueue.Arn
                  - !GetAtt ExecutionFifoQueue.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:BatchWriteItem
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              # Per-trade execution: Execution runs table access
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn

  # ========== TRADE AGGREGATOR LAMBDA ==========
  # Aggregates TradeExecuted events and emits single AllTradesCompleted event
  # This eliminates race conditions in notifications by ensuring only one notification per run
  TradeAggregatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-trade-aggregator"
        - !Sub "alchemiser-${Stage}-trade-aggregator"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/trade_aggregator/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt TradeAggregatorExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog, alpaca-py for capital metrics)
      Timeout: 60  # Aggregation should be fast
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          EXECUTION_RUNS_TABLE_NAME: !Ref ExecutionRunsTable
      Events:
        TradeExecutedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.execution"
              detail-type:
                - "TradeExecuted"
    Metadata:
      BuildMethod: python3.12

  TradeAggregatorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: TradeAggregatorPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ExecutionRunsTable.Arn

  # ========== NOTIFICATIONS LAMBDA ==========
  # Consumes TradeExecuted and WorkflowFailed events and sends email notifications
  NotificationsFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-notifications"
        - !Sub "alchemiser-${Stage}-notifications"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/notifications/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt NotificationsExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer        # Shared code (the_alchemiser.shared)
        - !Ref NotificationsLayer     # alpaca-py (for account metrics)
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          SNS_NOTIFICATION_TOPIC_ARN: !Ref TradingNotificationsTopic
          PERFORMANCE_REPORTS_BUCKET: !Ref PerformanceReportsBucket
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          # SES Configuration
          SES_FROM_ADDRESS: noreply@mail.octarine.capital
          SES_FROM_NAME: "Octarine Capital"
          SES_REPLY_TO_ADDRESS: noreply@mail.octarine.capital
          SES_REGION: !Ref AWS::Region
          # Environment-safe routing (override recipients in non-prod)
          NOTIFICATIONS_TO_PROD: notifications@rwxt.org
          NOTIFICATIONS_TO_NONPROD: notifications@rwxt.org
          # Safety: non-prod environments must explicitly enable real emails
          ALLOW_REAL_EMAILS: !If [ IsProduction, "true", "false" ]
      Events:
        # AllTradesCompleted from TradeAggregator (one event per run, no racing)
        AllTradesCompletedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.trade_aggregator"
              detail-type:
                - "AllTradesCompleted"
        # Route WorkflowFailed from ANY alchemiser source to notifications
        # Each Lambda (strategy, portfolio, execution) publishes WorkflowFailed with its own source
        WorkflowFailedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - prefix: "alchemiser."
              detail-type:
                - "WorkflowFailed"
        # DataLakeUpdateCompleted from Data Lambda (market data refresh success)
        DataLakeUpdateCompletedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.data"
              detail-type:
                - "DataLakeUpdateCompleted"
        # ScheduleCreated from Schedule Manager (schedule set, early close, or holiday skip)
        ScheduleCreatedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.coordinator"
              detail-type:
                - "ScheduleCreated"
    Metadata:
      BuildMethod: python3.12
      # BuildProperties removed - SAM auto-includes everything in CodeUri

  NotificationsExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: NotificationsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Ref TradingNotificationsTopic
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:GetItem
                  - dynamodb:Scan
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  - !Sub "${PerformanceReportsBucket.Arn}/*"
              # SES permissions for email sending
              - Effect: Allow
                Action:
                  - ses:SendEmail
                  - ses:SendRawEmail
                Resource: "*"

  # ========== METRICS LAMBDA (PRODUCTION ONLY) ==========
  # Publishes per-strategy realized P&L metrics to CloudWatch for dashboard visualization
  MetricsFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "alchemiser-${Stage}-metrics"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/metrics/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt MetricsExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer
        - !Ref NotificationsLayer  # Minimal dependencies (pydantic, structlog, boto3)
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          TRADE_LEDGER__TABLE_NAME: !Ref TradeLedgerTable
          STAGE: !Ref Stage
      Events:
        TradeExecutedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.execution"
              detail-type:
                - "TradeExecuted"
    Metadata:
      BuildMethod: python3.12

  MetricsExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: MetricsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:GetItem
                  - dynamodb:Scan
                Resource:
                  - !GetAtt TradeLedgerTable.Arn
                  - !Sub "${TradeLedgerTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: "*"

  # ========== DATA LAMBDA FUNCTION (PER-STAGE) ==========
  # Market data fetching and S3 storage (replaces alchemiser-shared-data)
  # Each stage gets own data function with own S3 bucket
  DataFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-data"
        - !Sub "alchemiser-${Stage}-data"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/data/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt DataExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer
        - !Ref DataLayer
      Timeout: 900
      MemorySize: 1024
      Environment:
        Variables:
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          MARKET_DATA_BUCKET: !Ref MarketDataBucket
          FETCH_REQUESTS_TABLE: !Ref MarketDataFetchRequestsTable
          BAD_DATA_MARKERS_TABLE: !Ref BadDataMarkersTable
          FETCH_COOLDOWN_MINUTES: !Ref FetchCooldownMinutes
          ALPACA__KEY: !If [ IsProduction, !Ref ProdAlpacaKey, !If [ IsStaging, !Ref StagingAlpacaKey, !Ref AlpacaKey ] ]
          ALPACA__SECRET: !If [ IsProduction, !Ref ProdAlpacaSecret, !If [ IsStaging, !Ref StagingAlpacaSecret, !Ref AlpacaSecret ] ]
          ALPACA__ENDPOINT: !If [ IsProduction, !Ref ProdAlpacaEndpoint, !If [ IsStaging, !Ref StagingAlpacaEndpoint, !Ref AlpacaEndpoint ] ]
      Events:
        # Scheduled data refresh (stage-specific times)
        DataSchedule:
          Type: Schedule
          Properties:
            Schedule: !If
              - IsProduction
              - !Ref DataRefreshScheduleProd
              - !If [ IsStaging, !Ref DataRefreshScheduleStaging, !Ref DataRefreshScheduleDev ]
            Description: !Sub "Refresh market data for ${Stage}"
        # On-demand fetch requests from strategy lambdas
        MarketDataFetchRequested:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref AlchemiserEventBus
            Pattern:
              source:
                - "alchemiser.strategy"
              detail-type:
                - "MarketDataFetchRequested"
    Metadata:
      BuildMethod: python3.12

  DataExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DataPolicy
          PolicyDocument:
            Statement:
              # S3 read/write for market data
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:ListBucket
                  - s3:DeleteObject
                Resource:
                  - !GetAtt MarketDataBucket.Arn
                  - !Sub "${MarketDataBucket.Arn}/*"
              # DynamoDB for fetch request deduplication
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt MarketDataFetchRequestsTable.Arn
              # DynamoDB for bad data markers
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt BadDataMarkersTable.Arn
              # EventBridge for publishing completion events
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn

  # EventBridge permission for Data Lambda invocation
  DataEventBridgePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DataFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AlchemiserEventBus.Name}/*"

  # REMOVED: Production fallback schedule (was at 3:50 PM ET Mon-Fri)
  # The fallback schedule was causing double runs when the dynamic schedule succeeded.
  # All environments (dev/staging/prod) now rely solely on the Schedule Manager for dynamic scheduling.
  # The Schedule Manager creates one-time schedules at 15 minutes before market close (accounting for early close days).
  # If the Schedule Manager fails, we will be notified through normal WorkflowFailed event channels.
  # Historical note: The fallback was intended as a "safety net" but added unnecessary complexity.
  #
  # StrategySchedule resource removed - see issue "Double run bug" for details.

  StrategySchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: scheduler.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeStrategy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt StrategyFunction.Arn
                  - !GetAtt StrategyOrchestratorFunction.Arn

  # ========== SCHEDULE MANAGER (Dynamic Early Close Handling) ==========
  # This Lambda runs early each trading day to create a one-time schedule
  # for the Strategy Orchestrator, accounting for early close days.

  ScheduleManagerFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-schedule-manager"
        - !Sub "alchemiser-${Stage}-schedule-manager"
      Runtime: python3.12
      Architectures:
        - x86_64
      CodeUri: functions/schedule_manager/
      Handler: lambda_handler.lambda_handler
      Role: !GetAtt ScheduleManagerExecutionRole.Arn
      Layers:
        - !Ref SharedCodeLayer
        - !Ref NotificationsLayer
      Timeout: 60
      MemorySize: 256
      Environment:
        Variables:
          ORCHESTRATOR_FUNCTION_ARN: !GetAtt StrategyOrchestratorFunction.Arn
          SCHEDULER_ROLE_ARN: !GetAtt StrategySchedulerRole.Arn
          SCHEDULE_GROUP_NAME: "default"
          MINUTES_BEFORE_CLOSE: "15"
          EVENT_BUS_NAME: !Ref AlchemiserEventBus
          # ALPACA__KEY, ALPACA__SECRET, ALPACA__ENDPOINT come from Globals
    Metadata:
      BuildMethod: python3.12

  ScheduleManagerExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ScheduleManagerPolicy
          PolicyDocument:
            Statement:
              # Permission to create/delete EventBridge Scheduler rules
              - Effect: Allow
                Action:
                  - scheduler:CreateSchedule
                  - scheduler:DeleteSchedule
                  - scheduler:GetSchedule
                Resource:
                  - !Sub "arn:aws:scheduler:${AWS::Region}:${AWS::AccountId}:schedule/default/*-trading-execution-*"
              # Permission to pass role to scheduler
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  - !GetAtt StrategySchedulerRole.Arn
                Condition:
                  StringEquals:
                    iam:PassedToService: scheduler.amazonaws.com
              # Permission to publish events to EventBridge
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource:
                  - !GetAtt AlchemiserEventBus.Arn

  # Morning schedule to trigger Schedule Manager (checks calendar and sets up today's execution)
  ScheduleManagerSchedule:
    Type: AWS::Scheduler::Schedule
    Properties:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-schedule-manager"
        - !Sub "alchemiser-${Stage}-schedule-manager"
      Description: "Run Schedule Manager at 9:00 AM ET to set up today's trading schedule"
      ScheduleExpression: "cron(0 9 ? * MON-FRI *)"
      ScheduleExpressionTimezone: "America/New_York"
      FlexibleTimeWindow:
        Mode: "OFF"
      Target:
        Arn: !GetAtt ScheduleManagerFunction.Arn
        RoleArn: !GetAtt ScheduleManagerSchedulerRole.Arn
        Input: '{"source": "morning_schedule"}'
        RetryPolicy:
          MaximumRetryAttempts: 2

  ScheduleManagerSchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: scheduler.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeScheduleManager
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt ScheduleManagerFunction.Arn

  # ============================================================================
  # END MICROSERVICES ARCHITECTURE
  # ============================================================================
  # Note: Data Lambda moved to shared infrastructure (data-template.yaml)
  # The shared Data Lambda serves all stages from alchemiser-shared-data

  # ============================================================================
  # OBSERVABILITY: CloudWatch Logs Insights & Dashboard
  # ============================================================================
  
  # CloudWatch Dashboard for at-a-glance monitoring
  # Note: Log groups are auto-created by Lambda; we reference them by name
  AlchemiserDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !If
        - UseStackNameForResources
        - !Sub "${StackName}-monitoring"
        - !Sub "alchemiser-${Stage}-monitoring"
      DashboardBody: !Sub
        - |
          {
            "widgets": [
              {
                "type": "log",
                "properties": {
                  "title": "Latest Errors & Warnings (All Lambdas)",
                  "region": "${AWS::Region}",
                  "query": "SOURCE '${StrategyLog}'\n| SOURCE '${OrchestratorLog}'\n| SOURCE '${AggregatorLog}'\n| SOURCE '${PortfolioLog}'\n| SOURCE '${ExecutionLog}'\n| SOURCE '${NotificationsLog}'\n| SOURCE '${MetricsLog}'\n| SOURCE '${DataLog}'\n| fields @timestamp, @log, level, event, module, correlation_id, message\n| filter level in ['error', 'warn', 'warning']\n| sort @timestamp desc\n| limit 50"
                },
                "x": 0,
                "y": 0,
                "width": 24,
                "height": 8
              },
              {
                "type": "log",
                "properties": {
                  "title": "Errors by Correlation ID (Trace Workflow Runs)",
                  "region": "${AWS::Region}",
                  "query": "SOURCE '${StrategyLog}'\n| SOURCE '${OrchestratorLog}'\n| SOURCE '${AggregatorLog}'\n| SOURCE '${PortfolioLog}'\n| SOURCE '${ExecutionLog}'\n| SOURCE '${NotificationsLog}'\n| SOURCE '${MetricsLog}'\n| SOURCE '${DataLog}'\n| fields @timestamp, @log, level, event, module, correlation_id, message\n| filter level = 'error'\n| sort @timestamp desc\n| limit 100"
                },
                "x": 0,
                "y": 8,
                "width": 24,
                "height": 8
              },
              {
                "type": "log",
                "properties": {
                  "title": "Recent Workflow Runs (by correlation_id)",
                  "region": "${AWS::Region}",
                  "query": "SOURCE '${StrategyLog}'\n| SOURCE '${OrchestratorLog}'\n| SOURCE '${AggregatorLog}'\n| SOURCE '${PortfolioLog}'\n| SOURCE '${ExecutionLog}'\n| SOURCE '${NotificationsLog}'\n| SOURCE '${MetricsLog}'\n| SOURCE '${DataLog}'\n| fields @timestamp, @log, level, event, correlation_id, module\n| filter event like /SignalGenerated|PartialSignalGenerated|RebalancePlanned|TradeExecuted|WorkflowCompleted|WorkflowFailed/\n| sort @timestamp desc\n| limit 50"
                },
                "x": 0,
                "y": 16,
                "width": 24,
                "height": 8
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Realized P&L by Strategy (Last 30 Days)",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 86400,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "RealizedPnL", { "stat": "Sum" } ]
                  ],
                  "yAxis": {
                    "left": {
                      "label": "P&L ($)"
                    }
                  },
                  "view": "timeSeries",
                  "stacked": false
                },
                "x": 0,
                "y": 24,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Cumulative Realized P&L (All Strategies)",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 2592000,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "RealizedPnL", { "stat": "Sum" } ]
                  ],
                  "view": "singleValue"
                },
                "x": 12,
                "y": 24,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Trade Count (Last 7 Days)",
                  "region": "${AWS::Region}",
                  "stat": "SampleCount",
                  "period": 86400,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "RealizedPnL", { "stat": "SampleCount" } ]
                  ],
                  "yAxis": {
                    "left": {
                      "label": "Trades"
                    }
                  },
                  "view": "timeSeries",
                  "stacked": false
                },
                "x": 18,
                "y": 24,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Capital Deployed (Last 7 Days)",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 86400,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "CapitalDeployedPct", { "stat": "Average" } ]
                  ],
                  "yAxis": {
                    "left": {
                      "label": "%",
                      "min": 0,
                      "max": 100
                    }
                  },
                  "view": "timeSeries",
                  "stacked": false
                },
                "x": 0,
                "y": 30,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Current Capital Deployed",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 300,
                  "metrics": [
                    [ "Alchemiser/${StageTitle}", "CapitalDeployedPct", { "stat": "Average" } ]
                  ],
                  "view": "singleValue"
                },
                "x": 12,
                "y": 30,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "P&L by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 86400,
                  "view": "timeSeries",
                  "stacked": false,
                  "yAxis": { "left": { "label": "P&L ($)" } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} RealizedPnL', 'Sum', 86400)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 0,
                "y": 36,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Win Rate by Strategy (%)",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 86400,
                  "view": "timeSeries",
                  "stacked": false,
                  "yAxis": { "left": { "label": "%", "min": 0, "max": 100 } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} WinRate', 'Average', 86400)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 12,
                "y": 36,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Open Position Value by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 3600,
                  "view": "timeSeries",
                  "stacked": true,
                  "yAxis": { "left": { "label": "Value ($)" } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} OpenPositionValue', 'Average', 3600)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 0,
                "y": 42,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Open Lots by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 3600,
                  "view": "timeSeries",
                  "stacked": true,
                  "yAxis": { "left": { "label": "Count", "min": 0 } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} OpenLotCount', 'Average', 3600)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 12,
                "y": 42,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Closed Lots by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Sum",
                  "period": 86400,
                  "view": "timeSeries",
                  "stacked": true,
                  "yAxis": { "left": { "label": "Count", "min": 0 } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} ClosedLotCount', 'Sum', 86400)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 18,
                "y": 42,
                "width": 6,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Winning vs Losing Trades by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 86400,
                  "view": "bar",
                  "stacked": false,
                  "yAxis": { "left": { "label": "Count" } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} WinningTrades', 'Average', 86400)", "label": "", "id": "e1" } ],
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} LosingTrades', 'Average', 86400)", "label": "", "id": "e2" } ]
                  ]
                },
                "x": 0,
                "y": 48,
                "width": 12,
                "height": 6
              },
              {
                "type": "metric",
                "properties": {
                  "title": "Avg Profit per Trade by Strategy",
                  "region": "${AWS::Region}",
                  "stat": "Average",
                  "period": 86400,
                  "view": "timeSeries",
                  "stacked": false,
                  "yAxis": { "left": { "label": "$ per trade" } },
                  "metrics": [
                    [ { "expression": "SEARCH('{Alchemiser/${StageTitle},StrategyName} AvgProfitPerTrade', 'Average', 86400)", "label": "", "id": "e1" } ]
                  ]
                },
                "x": 12,
                "y": 48,
                "width": 12,
                "height": 6
              }
            ]
          }
        - StrategyLog: !Sub "/aws/lambda/${StrategyFunction}"
          OrchestratorLog: !Sub "/aws/lambda/${StrategyOrchestratorFunction}"
          AggregatorLog: !Sub "/aws/lambda/${StrategyAggregatorFunction}"
          PortfolioLog: !Sub "/aws/lambda/${PortfolioFunction}"
          ExecutionLog: !Sub "/aws/lambda/${ExecutionFunction}"
          NotificationsLog: !Sub "/aws/lambda/${NotificationsFunction}"
          MetricsLog: !Sub "/aws/lambda/${MetricsFunction}"
          DataLog: !Sub "/aws/lambda/${DataFunction}"
          StageTitle: !FindInMap [StageConfig, !Ref Stage, TitleCase]

Outputs:
  TradeLedgerTableName:
    Description: "DynamoDB table for trade ledger persistence"
    Value: !Ref TradeLedgerTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-TradeLedgerTable"
        - !Sub "alchemiser-${Stage}-TradeLedgerTable"

  AggregationSessionsTableName:
    Description: "DynamoDB table for multi-node strategy aggregation sessions"
    Value: !Ref AggregationSessionsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-AggregationSessionsTable"
        - !Sub "alchemiser-${Stage}-AggregationSessionsTable"

  ExecutionRunsTableName:
    Description: "DynamoDB table for per-trade execution run tracking"
    Value: !Ref ExecutionRunsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-ExecutionRunsTable"
        - !Sub "alchemiser-${Stage}-ExecutionRunsTable"

  RebalancePlanTableName:
    Description: "DynamoDB table for rebalance plan auditability (90-day TTL)"
    Value: !Ref RebalancePlanTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-RebalancePlanTable"
        - !Sub "alchemiser-${Stage}-RebalancePlanTable"

  StrategyWeightsTableName:
    Description: "DynamoDB table for live strategy weights with Calmar-tilted adjustments"
    Value: !Ref StrategyWeightsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-StrategyWeightsTable"
        - !Sub "alchemiser-${Stage}-StrategyWeightsTable"

  ExecutionFifoQueueUrl:
    Description: "SQS Standard queue for parallel per-trade execution"
    Value: !Ref ExecutionFifoQueue
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-ExecutionFifoQueue"
        - !Sub "alchemiser-${Stage}-ExecutionFifoQueue"

  PerformanceReportsBucketName:
    Description: "S3 bucket for strategy performance CSV reports"
    Value: !Ref PerformanceReportsBucket
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-PerformanceReportsBucket"
        - !Sub "alchemiser-${Stage}-PerformanceReportsBucket"

  MarketDataBucketName:
    Description: "Per-stage S3 bucket for historical market data (Parquet files)"
    Value: !Ref MarketDataBucket
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-MarketDataBucket"
        - !Sub "alchemiser-${Stage}-MarketDataBucket"

  MarketDataFetchRequestsTableName:
    Description: "DynamoDB table for fetch request deduplication"
    Value: !Ref MarketDataFetchRequestsTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-MarketDataFetchRequestsTable"
        - !Sub "alchemiser-${Stage}-MarketDataFetchRequestsTable"

  BadDataMarkersTableName:
    Description: "DynamoDB table for bad data markers"
    Value: !Ref BadDataMarkersTable
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-BadDataMarkersTable"
        - !Sub "alchemiser-${Stage}-BadDataMarkersTable"

  DataFunctionArn:
    Description: "ARN of per-stage data function"
    Value: !GetAtt DataFunction.Arn
    Export:
      Name: !If
        - UseStackNameForResources
        - !Sub "${StackName}-DataFunction"
        - !Sub "alchemiser-${Stage}-DataFunction"

  DeploymentStage:
    Description: "Deployed stage"
    Value: !Ref Stage
  
  StackNameUsed:
    Description: "Stack name used for resource naming"
    Value: !If [ HasStackName, !Ref StackName, !Sub "alchemiser-${Stage}" ]


  DashboardURL:
    Description: "CloudWatch Dashboard for monitoring errors and warnings"
    Value: !Sub "https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${AlchemiserDashboard}"

  LogsInsightsURL:
    Description: "CloudWatch Logs Insights for querying logs across all Lambdas"
    Value: !Sub "https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#logsV2:logs-insights"

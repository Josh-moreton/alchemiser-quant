name: CD

on:
  # Prod deployments triggered by version tags (v*.*.*)
  push:
    tags:
      - 'v[0-9]*.[0-9]*.[0-9]*'
      - 'v[0-9]*.[0-9]*.[0-9]*-beta.[0-9]*'
      - 'v[0-9]*.[0-9]*.[0-9]*-staging.[0-9]*'
  # Allow manual deploys for either environment
  workflow_dispatch:
    inputs:
      environment:
        description: Which environment to deploy
        required: true
        default: dev
        type: choice
        options: [dev, staging, prod]

permissions:
  id-token: write
  contents: read

env:
  AWS_PAGER: ""

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ contains(github.ref_name, 'beta') && 'dev' || contains(github.ref_name, 'staging') && 'staging' || (github.event_name == 'workflow_dispatch' && inputs.environment || 'prod') }}
    # Ensure only one deploy per environment runs at a time
    concurrency:
      group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.ref || inputs.environment }}
      cancel-in-progress: true

    steps:
      - name: Checkout correct commit
        uses: actions/checkout@v6

      - name: Decide target environment
        id: target
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # Tag-based deployment
            if [[ "${{ github.ref_name }}" == *"beta"* ]]; then
              echo "env=dev" >> $GITHUB_OUTPUT
              echo "Deploying beta tag ${{ github.ref_name }} to dev"
            elif [[ "${{ github.ref_name }}" == *"staging"* ]]; then
              echo "env=staging" >> $GITHUB_OUTPUT
              echo "Deploying staging tag ${{ github.ref_name }} to staging"
            else
              echo "env=prod" >> $GITHUB_OUTPUT
              echo "Deploying release tag ${{ github.ref_name }} to prod"
            fi
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "env=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "env=dev" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.12"

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 1.8.3
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Cache venv
        uses: actions/cache@v5
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --no-interaction

      - name: Install SAM CLI
        uses: aws-actions/setup-sam@v2

      - name: Prepare environment variables (dev)
        if: steps.target.outputs.env == 'dev'
        env:
          ALPACA_KEY: ${{ secrets.ALPACA_KEY }}
          ALPACA_SECRET: ${{ secrets.ALPACA_SECRET }}
          ALPACA_ENDPOINT: ${{ vars.ALPACA_ENDPOINT }}
          EMAIL__PASSWORD: ${{ secrets.EMAIL__PASSWORD }}
          NOTIFICATION_EMAIL: ${{ vars.NOTIFICATION_EMAIL }}
          LOGGING__LEVEL: ${{ vars.LOGGING__LEVEL }}
          EQUITY_DEPLOYMENT_PCT: ${{ vars.EQUITY_DEPLOYMENT_PCT }}
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ vars.NOTION_DATABASE_ID }}
        run: |
          echo "Exporting dev ALPACA_* env vars for deploy.sh"
          echo "ALPACA_KEY=$ALPACA_KEY" >> $GITHUB_ENV
          echo "ALPACA_SECRET=$ALPACA_SECRET" >> $GITHUB_ENV
          if [ -n "$ALPACA_ENDPOINT" ]; then echo "ALPACA_ENDPOINT=$ALPACA_ENDPOINT" >> $GITHUB_ENV; fi
          if [ -n "$EMAIL__PASSWORD" ]; then echo "EMAIL__PASSWORD=$EMAIL__PASSWORD" >> $GITHUB_ENV; fi
          if [ -n "$NOTIFICATION_EMAIL" ]; then echo "NOTIFICATION_EMAIL=$NOTIFICATION_EMAIL" >> $GITHUB_ENV; fi
          # Non-secret runtime config
          if [ -n "$LOGGING__LEVEL" ]; then echo "LOGGING__LEVEL=$LOGGING__LEVEL" >> $GITHUB_ENV; fi
          if [ -n "$EQUITY_DEPLOYMENT_PCT" ]; then echo "EQUITY_DEPLOYMENT_PCT=$EQUITY_DEPLOYMENT_PCT" >> $GITHUB_ENV; fi
          # Notion P&L Dashboard
          if [ -n "$NOTION_TOKEN" ]; then echo "NOTION_TOKEN=$NOTION_TOKEN" >> $GITHUB_ENV; fi
          if [ -n "$NOTION_DATABASE_ID" ]; then echo "NOTION_DATABASE_ID=$NOTION_DATABASE_ID" >> $GITHUB_ENV; fi

      - name: Prepare environment variables (staging)
        if: steps.target.outputs.env == 'staging'
        env:
          ALPACA_KEY: ${{ secrets.ALPACA_KEY }}
          ALPACA_SECRET: ${{ secrets.ALPACA_SECRET }}
          ALPACA_ENDPOINT: ${{ vars.ALPACA_ENDPOINT }}
          EMAIL__PASSWORD: ${{ secrets.EMAIL__PASSWORD }}
          NOTIFICATION_EMAIL: ${{ vars.NOTIFICATION_EMAIL }}
          LOGGING__LEVEL: ${{ vars.LOGGING__LEVEL }}
          EQUITY_DEPLOYMENT_PCT: ${{ vars.EQUITY_DEPLOYMENT_PCT }}
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ vars.NOTION_DATABASE_ID }}
        run: |
          echo "Exporting staging ALPACA_* env vars for deploy.sh"
          echo "ALPACA_KEY=$ALPACA_KEY" >> $GITHUB_ENV
          echo "ALPACA_SECRET=$ALPACA_SECRET" >> $GITHUB_ENV
          if [ -n "$ALPACA_ENDPOINT" ]; then echo "ALPACA_ENDPOINT=$ALPACA_ENDPOINT" >> $GITHUB_ENV; fi
          if [ -n "$EMAIL__PASSWORD" ]; then echo "EMAIL__PASSWORD=$EMAIL__PASSWORD" >> $GITHUB_ENV; fi
          if [ -n "$NOTIFICATION_EMAIL" ]; then echo "NOTIFICATION_EMAIL=$NOTIFICATION_EMAIL" >> $GITHUB_ENV; fi
          # Non-secret runtime config
          if [ -n "$LOGGING__LEVEL" ]; then echo "LOGGING__LEVEL=$LOGGING__LEVEL" >> $GITHUB_ENV; fi
          if [ -n "$EQUITY_DEPLOYMENT_PCT" ]; then echo "EQUITY_DEPLOYMENT_PCT=$EQUITY_DEPLOYMENT_PCT" >> $GITHUB_ENV; fi
          # Notion P&L Dashboard
          if [ -n "$NOTION_TOKEN" ]; then echo "NOTION_TOKEN=$NOTION_TOKEN" >> $GITHUB_ENV; fi
          if [ -n "$NOTION_DATABASE_ID" ]; then echo "NOTION_DATABASE_ID=$NOTION_DATABASE_ID" >> $GITHUB_ENV; fi

      - name: Prepare environment variables (prod)
        if: steps.target.outputs.env == 'prod'
        env:
          ALPACA_KEY: ${{ secrets.ALPACA_KEY }}
          ALPACA_SECRET: ${{ secrets.ALPACA_SECRET }}
          ALPACA_ENDPOINT: ${{ vars.ALPACA_ENDPOINT }}
          EMAIL__PASSWORD: ${{ secrets.EMAIL__PASSWORD }}
          NOTIFICATION_EMAIL: ${{ vars.NOTIFICATION_EMAIL }}
          LOGGING__LEVEL: ${{ vars.LOGGING__LEVEL }}
          EQUITY_DEPLOYMENT_PCT: ${{ vars.EQUITY_DEPLOYMENT_PCT }}
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ vars.NOTION_DATABASE_ID }}
        run: |
          echo "Exporting prod ALPACA_* env vars for deploy.sh"
          echo "ALPACA_KEY=$ALPACA_KEY" >> $GITHUB_ENV
          echo "ALPACA_SECRET=$ALPACA_SECRET" >> $GITHUB_ENV
          if [ -n "$ALPACA_ENDPOINT" ]; then echo "ALPACA_ENDPOINT=$ALPACA_ENDPOINT" >> $GITHUB_ENV; fi
          if [ -n "$EMAIL__PASSWORD" ]; then echo "EMAIL__PASSWORD=$EMAIL__PASSWORD" >> $GITHUB_ENV; fi
          if [ -n "$NOTIFICATION_EMAIL" ]; then echo "NOTIFICATION_EMAIL=$NOTIFICATION_EMAIL" >> $GITHUB_ENV; fi
          # Non-secret runtime config
          if [ -n "$LOGGING__LEVEL" ]; then echo "LOGGING__LEVEL=$LOGGING__LEVEL" >> $GITHUB_ENV; fi
          if [ -n "$EQUITY_DEPLOYMENT_PCT" ]; then echo "EQUITY_DEPLOYMENT_PCT=$EQUITY_DEPLOYMENT_PCT" >> $GITHUB_ENV; fi
          # Notion P&L Dashboard
          if [ -n "$NOTION_TOKEN" ]; then echo "NOTION_TOKEN=$NOTION_TOKEN" >> $GITHUB_ENV; fi
          if [ -n "$NOTION_DATABASE_ID" ]; then echo "NOTION_DATABASE_ID=$NOTION_DATABASE_ID" >> $GITHUB_ENV; fi

      - name: Deploy
        run: |
          ENV="${{ steps.target.outputs.env }}"
          SHARED_STACK="alchemiser-${ENV}-shared"
          chmod +x scripts/deploy.sh scripts/migrate-to-multi-stack.sh

          # Check if the shared stack exists AND is in a healthy state
          SHARED_STATUS=$(aws cloudformation describe-stacks --stack-name "$SHARED_STACK" \
            --query 'Stacks[0].StackStatus' --output text --no-cli-pager 2>/dev/null || echo "DOES_NOT_EXIST")

          # Only treat as healthy if in a *_COMPLETE state (not REVIEW_IN_PROGRESS,
          # *_FAILED, *_IN_PROGRESS, ROLLBACK_*, etc.)
          if [[ "$SHARED_STATUS" == *_COMPLETE ]] && [[ "$SHARED_STATUS" != "ROLLBACK_COMPLETE" ]]; then
            echo "Shared stack healthy ($SHARED_STATUS) - running normal deploy..."
            ./scripts/deploy.sh "$ENV"
          else
            echo "Shared stack absent or unhealthy ($SHARED_STATUS) - running one-time migration..."
            echo "y" | ./scripts/migrate-to-multi-stack.sh "$ENV"
          fi

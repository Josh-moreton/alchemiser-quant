name: Manual Destroy Ephemeral

on:
  workflow_dispatch:
    inputs:
      stack_name:
        description: 'Ephemeral stack name to destroy (must start with alchemiser-ephem-)'
        required: true
        type: string

permissions:
  id-token: write
  contents: read

env:
  AWS_PAGER: ""

jobs:
  destroy-ephemeral:
    runs-on: ubuntu-latest
    environment: dev
    
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Validate stack name
        id: validate
        env:
          STACK_NAME: ${{ inputs.stack_name }}
        run: |
          echo "Validating stack name: $STACK_NAME"
          
          # Must start with alchemiser-ephem- to ensure we only destroy ephemeral stacks
          if [[ ! "$STACK_NAME" =~ ^alchemiser-ephem- ]]; then
            echo "âŒ ERROR: Stack name must start with 'alchemiser-ephem-'"
            echo "ðŸ’¡ This workflow can only destroy ephemeral stacks"
            echo "ðŸ“‹ Provided: $STACK_NAME"
            exit 1
          fi
          
          # Prevent destruction of main stacks
          if [[ "$STACK_NAME" =~ (the-alchemiser-v2$|the-alchemiser-v2-dev$|the-alchemiser-v2-prod$) ]]; then
            echo "âŒ ERROR: Cannot destroy protected stack: $STACK_NAME"
            echo "ðŸ’¡ Use the standard CD workflow for dev/prod stacks"
            exit 1
          fi
          
          echo "âœ… Stack name validation passed"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install SAM CLI
        uses: aws-actions/setup-sam@v2

      - name: Verify stack exists and is ephemeral
        env:
          STACK_NAME: ${{ inputs.stack_name }}
        run: |
          echo "Checking if stack exists: $STACK_NAME"
          
          # Check if stack exists
          if ! aws cloudformation describe-stacks --stack-name "$STACK_NAME" >/dev/null 2>&1; then
            echo "âš ï¸  WARNING: Stack $STACK_NAME does not exist or is already deleted"
            echo "Stack may have been already destroyed or never created"
            exit 0
          fi
          
          # Verify it's tagged as ephemeral
          EPHEMERAL_TAG=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Tags[?Key==`Ephemeral`].Value' \
            --output text)
          
          if [ "$EPHEMERAL_TAG" != "true" ]; then
            echo "âŒ ERROR: Stack $STACK_NAME is not tagged as ephemeral"
            echo "ðŸ’¡ This workflow can only destroy stacks with Ephemeral=true tag"
            exit 1
          fi
          
          echo "âœ… Stack exists and is ephemeral"

      - name: Get stack resources for cleanup
        id: resources
        env:
          STACK_NAME: ${{ inputs.stack_name }}
        run: |
          echo "Gathering stack resources for cleanup..."
          
          # Get S3 bucket name if it exists
          BUCKET_NAME=$(aws cloudformation describe-stack-resources \
            --stack-name "$STACK_NAME" \
            --query "StackResources[?ResourceType=='AWS::S3::Bucket'].PhysicalResourceId" \
            --output text 2>/dev/null || echo "")
          
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT
          
          # Get log group name if it exists
          LOG_GROUP=$(aws cloudformation describe-stack-resources \
            --stack-name "$STACK_NAME" \
            --query "StackResources[?ResourceType=='AWS::Logs::LogGroup'].PhysicalResourceId" \
            --output text 2>/dev/null || echo "")
          
          echo "log_group=$LOG_GROUP" >> $GITHUB_OUTPUT
          
          echo "Resources found:"
          echo "  S3 Bucket: ${BUCKET_NAME:-none}"
          echo "  Log Group: ${LOG_GROUP:-none}"

      - name: Empty S3 bucket
        if: steps.resources.outputs.bucket_name != ''
        env:
          BUCKET_NAME: ${{ steps.resources.outputs.bucket_name }}
        run: |
          echo "Emptying S3 bucket: $BUCKET_NAME"
          
          # Check if bucket exists
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Deleting all objects and versions from bucket..."
            aws s3 rm "s3://$BUCKET_NAME" --recursive || true
            
            # Delete all versions if versioning is enabled
            aws s3api list-object-versions \
              --bucket "$BUCKET_NAME" \
              --query 'Versions[].{Key:Key,VersionId:VersionId}' \
              --output text 2>/dev/null | \
              while read key versionId; do
                [ -n "$key" ] && aws s3api delete-object \
                  --bucket "$BUCKET_NAME" \
                  --key "$key" \
                  --version-id "$versionId" 2>/dev/null || true
              done
            
            # Delete all delete markers
            aws s3api list-object-versions \
              --bucket "$BUCKET_NAME" \
              --query 'DeleteMarkers[].{Key:Key,VersionId:VersionId}' \
              --output text 2>/dev/null | \
              while read key versionId; do
                [ -n "$key" ] && aws s3api delete-object \
                  --bucket "$BUCKET_NAME" \
                  --key "$key" \
                  --version-id "$versionId" 2>/dev/null || true
              done
            
            echo "âœ… S3 bucket emptied"
          else
            echo "â„¹ï¸  Bucket does not exist or already deleted"
          fi

      - name: Delete CloudFormation stack
        env:
          STACK_NAME: ${{ inputs.stack_name }}
        run: |
          echo "ðŸ—‘ï¸  Deleting CloudFormation stack: $STACK_NAME"
          
          sam delete \
            --stack-name "$STACK_NAME" \
            --no-prompts \
            --region ${{ secrets.AWS_REGION }}
          
          echo "âœ… Stack deletion initiated"

      - name: Wait for stack deletion
        env:
          STACK_NAME: ${{ inputs.stack_name }}
        run: |
          echo "Waiting for stack deletion to complete..."
          
          # Wait for stack to be deleted (timeout after 15 minutes)
          TIMEOUT=900
          ELAPSED=0
          INTERVAL=10
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --query 'Stacks[0].StackStatus' \
              --output text 2>/dev/null || echo "DELETE_COMPLETE")
            
            if [ "$STATUS" = "DELETE_COMPLETE" ] || [ "$STATUS" = "" ]; then
              echo "âœ… Stack deleted successfully"
              break
            elif [ "$STATUS" = "DELETE_FAILED" ]; then
              echo "âŒ Stack deletion failed"
              echo "Check CloudFormation console for details"
              exit 1
            else
              echo "Status: $STATUS (waiting...)"
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            fi
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âš ï¸  Deletion timeout reached, but stack deletion may still be in progress"
            echo "Check CloudFormation console for status"
          fi

      - name: Cleanup orphaned resources
        env:
          STACK_NAME: ${{ inputs.stack_name }}
          LOG_GROUP: ${{ steps.resources.outputs.log_group }}
        run: |
          echo "Cleaning up any orphaned resources..."
          
          # Delete log group if it still exists
          if [ -n "$LOG_GROUP" ]; then
            if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" 2>/dev/null | grep -q "$LOG_GROUP"; then
              echo "Deleting log group: $LOG_GROUP"
              aws logs delete-log-group --log-group-name "$LOG_GROUP" 2>/dev/null || true
            fi
          fi
          
          # Clean up any S3 deployment artifacts for this stack
          # SAM creates buckets like aws-sam-cli-managed-default-samclisourcebucket-*
          # with prefixes matching the stack name
          echo "Checking for orphaned SAM deployment artifacts..."
          SAM_BUCKETS=$(aws s3 ls | grep "aws-sam-cli-managed" | awk '{print $3}')
          for bucket in $SAM_BUCKETS; do
            echo "  Checking bucket: $bucket"
            aws s3 rm "s3://$bucket/$STACK_NAME/" --recursive 2>/dev/null || true
          done
          
          echo "âœ… Cleanup complete"

      - name: Summary
        env:
          STACK_NAME: ${{ inputs.stack_name }}
        run: |
          echo ""
          echo "ðŸŽ‰ Ephemeral stack destroyed successfully!"
          echo "ðŸ“‹ Stack name: $STACK_NAME"
          echo ""
          echo "All resources associated with this stack have been removed."

# Rationale: enforce immutability and lightweight domain model using dataclass with slots and kw_only
--- a/the_alchemiser/domain/models/account.py
+++ b/the_alchemiser/domain/models/account.py
@@
-from dataclasses import (
-    dataclass,
-)  # TODO(PYDANTIC-MIGRATION): Convert this and other domain dataclasses in core/models to Pydantic BaseModel (frozen=True) for
-runtime validation & parsing. Keep boundary TypedDicts in core.types as IO schema. Ensure numeric string coercion moves into Pyd
-antic validators and remove manual float(...) casts in from_dict during migration.
+from dataclasses import dataclass, field
@@
-@dataclass(
-    frozen=True
-)  # TODO(PYDANTIC-MIGRATION): Replace with Pydantic model AccountModel(BaseModel) (frozen) providing validators for numeric coe
-rcion and status literal enforcement.
-class AccountModel:
+@dataclass(frozen=True, slots=True, kw_only=True)
+class Account:
@@
-    account_id: str
-    equity: float
-    cash: float
-    buying_power: float
-    day_trades_remaining: int
-    portfolio_value: float
-    last_equity: float
-    daytrading_buying_power: float
-    regt_buying_power: float
-    status: Literal["ACTIVE", "INACTIVE"]
+    account_id: str
+    equity: float
+    cash: float
+    buying_power: float
+    day_trades_remaining: int
+    portfolio_value: float
+    last_equity: float
+    daytrading_buying_power: float
+    regt_buying_power: float
+    status: Literal["ACTIVE", "INACTIVE"]
@@
-    @classmethod
-    def from_dict(cls, data: AccountInfo) -> "AccountModel":
+    @classmethod
+    def from_dict(cls, data: AccountInfo) -> "Account":
@@
-    def to_dict(self) -> AccountInfo:
-        """Convert to AccountInfo TypedDict."""
-        return {
-            "account_id": self.account_id,
-            "equity": self.equity,
-            "cash": self.cash,
-            "buying_power": self.buying_power,
-            "day_trades_remaining": self.day_trades_remaining,
-            "portfolio_value": self.portfolio_value,
-            "last_equity": self.last_equity,
-            "daytrading_buying_power": self.daytrading_buying_power,
-            "regt_buying_power": self.regt_buying_power,
-            "status": self.status,
-        }
+    def to_dict(self) -> AccountInfo:
+        """Serialize to TypedDict for IO boundaries."""
+        return {
+            "account_id": self.account_id,
+            "equity": self.equity,
+            "cash": self.cash,
+            "buying_power": self.buying_power,
+            "day_trades_remaining": self.day_trades_remaining,
+            "portfolio_value": self.portfolio_value,
+            "last_equity": self.last_equity,
+            "daytrading_buying_power": self.daytrading_buying_power,
+            "regt_buying_power": self.regt_buying_power,
+            "status": self.status,
+        }

# Rationale: domain order model should be a frozen, slotted dataclass and separate parsing from domain state
--- a/the_alchemiser/domain/models/order.py
+++ b/the_alchemiser/domain/models/order.py
@@
-from dataclasses import (
-    dataclass,
-)  # TODO(PYDANTIC-MIGRATION): Convert OrderModel to Pydantic BaseModel or reuse ValidatedOrder; de-duplicate order representations.
+from dataclasses import dataclass
@@
-@dataclass(
-    frozen=True
-)  # TODO(PYDANTIC-MIGRATION): Replace with OrderModel(BaseModel) or remove if ValidatedOrder supersedes; ensure single source of truth.
-class OrderModel:
+@dataclass(frozen=True, slots=True, kw_only=True)
+class Order:
@@
-    id: str
-    symbol: str
-    qty: float
-    side: Literal["buy", "sell"]
-    order_type: Literal["market", "limit", "stop", "stop_limit"]
-    time_in_force: Literal["day", "gtc", "ioc", "fok"]
-    status: Literal["new", "partially_filled", "filled", "canceled", "expired", "rejected"]
-    filled_qty: float
-    filled_avg_price: float | None
-    created_at: datetime
-    updated_at: datetime
+    id: str
+    symbol: str
+    qty: float
+    side: Literal["buy", "sell"]
+    order_type: Literal["market", "limit", "stop", "stop_limit"]
+    time_in_force: Literal["day", "gtc", "ioc", "fok"]
+    status: Literal["new", "partially_filled", "filled", "canceled", "expired", "rejected"]
+    filled_qty: float
+    filled_avg_price: float | None
+    created_at: datetime
+    updated_at: datetime
@@
-    def from_dict(cls, data: OrderDetails) -> "OrderModel":
+    def from_dict(cls, data: OrderDetails) -> "Order":
@@
-    def to_dict(self) -> OrderDetails:
-        """Convert to OrderDetails TypedDict."""
-        return {
-            "id": self.id,
-            "symbol": self.symbol,
-            "qty": self.qty,
-            "side": self.side,
-            "order_type": self.order_type,
-            "time_in_force": self.time_in_force,
-            "status": self.status,
-            "filled_qty": self.filled_qty,
-            "filled_avg_price": self.filled_avg_price,
-            "created_at": self.created_at.isoformat(),
-            "updated_at": self.updated_at.isoformat(),
-        }
+    def to_dict(self) -> OrderDetails:
+        """Serialize to TypedDict for persistence or APIs."""
+        return {
+            "id": self.id,
+            "symbol": self.symbol,
+            "qty": self.qty,
+            "side": self.side,
+            "order_type": self.order_type,
+            "time_in_force": self.time_in_force,
+            "status": self.status,
+            "filled_qty": self.filled_qty,
+            "filled_avg_price": self.filled_avg_price,
+            "created_at": self.created_at.isoformat(),
+            "updated_at": self.updated_at.isoformat(),
+        }

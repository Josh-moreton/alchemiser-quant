# TypedDict vs Dataclass Usage in The Alchemiser

## When to Keep **TypedDict** Definitions

* **External API Data Structures:** Continue using `TypedDict` for any data structure that mirrors Alpaca’s API responses or other external JSON payloads. For example, the code defines `AccountInfo` and `PositionInfo` as `TypedDict` types for account and position data, and `OrderDetails` for order info. These should remain `TypedDict` because they align exactly with the fields returned by Alpaca (strings/numbers for equity, qty, etc.) and are convenient for direct JSON/dict parsing and serialization. Keeping them as `TypedDict` ensures static type checking for keys while working with raw API dictionaries.

* **Transient Integration/Result Containers:** Use `TypedDict` for structures that are primarily used to transfer or aggregate data across system boundaries (or for logging/outputs) without needing internal methods. Examples include the execution and planning results like `ExecutionResult` (which bundles executed orders and pre/post-trade account states), trading plan instructions (`TradingPlan` with symbol/action/quantity), WebSocket outcomes (`WebSocketResult` with status/message), and limit order submission results (`LimitOrderResult`). These are effectively *records* of information and can stay as `TypedDict` for clarity. They often get serialized to JSON or passed to external systems, so keeping them as dicts (with type hints) is natural.

* **Strategy Signal & Performance Data (for Aggregation/Output):** Retain `TypedDict` for summary or reporting structures that collate strategy outcomes or metrics. For instance, `StrategySignal` (fields for symbol, action, confidence, etc.) is defined as a `TypedDict` and is useful when collecting raw signals from strategies (e.g. Nuclear, TECL, KLM) before conversion to models. Similarly, composite results like `StrategyPnLSummary` (total PnL, win rate, etc. per strategy) and `KLMVariantResult` are primarily containers for data – they can remain `TypedDict` since they may be used to assemble JSON reports or pass data between functions without needing behavior. The same applies to portfolio analytics types like `BacktestResult`, `PerformanceMetrics`, `TradeAnalysis`, and `PortfolioSnapshot` in **core/types.py** – these hold numeric results and lists for reporting, so a structured dict is sufficient.

* **CLI and Configuration Outputs:** Continue using `TypedDict` for command-line interface data structures and config-like records. The project defines several CLI-related types (e.g. `CLIOptions` for command flags, `CLIAccountDisplay` for account snapshot, `CLIOrderDisplay` for formatted order info). These are used to organize output data for printing or user display, where using a dict is straightforward. They don't have behavior attached, so a `TypedDict` is an appropriate lightweight choice. Likewise, `EmailReportData` (email subject/content info) and `EmailSummary` for notifications are basically payloads – they can remain as `TypedDict` because they’ll likely be converted to JSON or used in jinja templates for emails.

* **Error Logging Structures:** The error handling system also benefits from `TypedDict` for structured error info. Types like `ErrorDetailInfo` (detailed error fields), `ErrorReportSummary`, `ErrorNotificationData`, and `ErrorContextData` are declared as `TypedDict` in the types module. These should remain `TypedDict` because error details are collected into dictionaries for logging or email reports. For example, the `ErrorDetails.to_dict()` method constructs an `ErrorDetailInfo` dict for serialization. Using `TypedDict` here helps enforce that all expected fields (error\_message, traceback, etc.) are present when building these report dictionaries, without needing a full class.

* **Integration Events & Credentials:** Maintain `TypedDict` for structures that interface with outside systems or configs, where a dict is naturally expected. This includes the `LambdaEvent` (an AWS Lambda event payload with optional fields) and `EmailCredentials` for SMTP settings. These are essentially mappings of configuration data or event parameters — keeping them as `TypedDict` makes it easy to pass them directly to AWS Lambda handlers or email functions. They often have optional keys (notice `LambdaEvent` is defined with `total=False` for optional fields), which is handled cleanly by a `TypedDict` without requiring dummy defaults.

**Why TypedDict?** In all the above cases, `TypedDict` provides a clear schema for dictionaries that are used at system boundaries or for grouping data, without the overhead of classes. They are ideal when you expect to **serialize to JSON, interact with external libs, or treat the data as a plain mapping**. You should keep these as `TypedDict` definitions to preserve the flexibility of dictionaries while still getting mypy to check key names and value types.

## When to Use **Dataclasses** (or Pydantic Models) for Objects

* **Core Domain Models (Immutable):** Use `dataclass` instances for the main domain entities that your code manipulates and reasons about. The repository has already introduced frozen dataclasses for key concepts in **`the_alchemiser/core/models`** – these should be continued and expanded where appropriate:

  * **Account and Portfolio:** `AccountModel` represents an account with fields like equity, cash, status, etc. and `PortfolioHistoryModel` for the account’s P\&L history lists. These are defined as `@dataclass(frozen=True)` and should remain dataclasses. They encapsulate logic (e.g. methods or properties to compute latest equity or check emptiness) which wouldn’t be possible with a plain dict. The dataclass provides an immutable, typed object for internal calculations, while conversion methods bridge to/from the raw `AccountInfo` dict.
  * **Positions and Orders:** Similarly, `PositionModel` (for open positions) and `OrderModel` (for orders) are frozen dataclasses with clearly typed fields. They include convenience methods (e.g. `PositionModel.percentage_return` or `OrderModel.is_filled`) and handle type conversion (converting string quantities to floats, parsing timestamps) in their classmethods. Use dataclasses here to maintain those behaviors. For example, `OrderModel.from_dict()` takes an `OrderDetails` `TypedDict` and returns a strongly-typed object, parsing dates and numeric strings, and `to_dict()` does the reverse. This pattern – **TypedDict at the boundaries, dataclass for in-memory usage** – should be applied to all such domain data.
  * **Market Data Points:** The OHLCV bar data and quotes are handled by dataclasses like `BarModel` (for market bars) and `QuoteModel`. These are defined as immutable dataclasses with datetime fields and helper properties (e.g. `BarModel.is_valid_ohlc` to verify data integrity, `QuoteModel.spread` to compute bid-ask spread). Keep these as dataclasses because you benefit from automatic type conversion (the `from_dict` converts timestamps from ISO strings to `datetime` objects) and you can easily pass them around in the system with type safety. The `PriceDataModel` for last trade prices is another dataclass example. Whenever you have a structured piece of data like a market data point that the code will operate on (compute, compare, etc.), a dataclass is appropriate.
  * **Strategy Signals and Positions:** For the strategy layer, you’ve defined `StrategySignalModel` and `StrategyPositionModel` as dataclasses to represent a strategy’s signal (recommendation) and a strategy-specific position respectively. Continue using dataclasses here. For instance, a `StrategySignalModel` holds a strategy’s action (BUY/SELL/HOLD) plus a reasoning and allocation percentage; it has properties to interpret confidence levels. This is far easier to manage as an object than a raw dict. The corresponding `StrategySignal` and `StrategyPositionData` `TypedDict` definitions are used when assembling or disassembling these objects (e.g. constructing signals from strategy outputs or producing JSON summaries), but within the application logic (like multi-strategy management), you should prefer the dataclass models for type safety. As you integrate Nuclear/TECL/KLM strategy outputs, have them produce `StrategySignalModel` instances (or create them from the raw output) instead of anonymous dicts – this ensures each signal has the expected fields and methods (like `is_buy_signal` etc.).

* **Validated Data Models (with Pydantic):** In cases where you require runtime validation or more complex constraints, use Pydantic models (which are effectively dataclass-like objects with validation). The repo already employs a `ValidatedOrder` class (subclassing `BaseModel`) in **execution/order\_validation.py** to replace unstructured order dicts. This Pydantic model ensures an order has valid fields (quantity > 0, required prices for limit orders, etc.) and is immutable (configured with `frozen=True`). You should treat such Pydantic models similarly to dataclasses in terms of usage. For example, `ValidatedOrder` has methods to convert to/from the `OrderDetails` `TypedDict` for compatibility, but inside the execution logic you work with it as an object (with typed attributes like `quantity: Decimal`, `side: Enum` instead of raw strings). Whenever you need to enforce constraints (e.g. in order creation, risk checks, or config loading), a Pydantic model is a good choice. It provides the benefits of dataclasses (clear structure, type hints) plus validation. So, **use a Pydantic BaseModel in place of a plain dataclass** when you want automatic type parsing and validation on instantiation (as done for orders and also for config via `BaseSettings` in **core/config.py**).

* **Internal Helper Structures with Behavior:** Any other structured data that carries logic or computed properties should be a class (dataclass or similar). For instance, the error handling defines an `ErrorContext` class (to capture context and timestamp) and an `ErrorDetails` class – these are not dataclasses, but regular classes with methods like `to_dict()`. The choice to make them classes is to encapsulate behavior (adding timestamps, formatting traceback) which a raw dict cannot do. In general, if you find yourself wanting to add methods (e.g. `calculate_something()`, `is_valid()`, derived properties) or if the data is created and passed around multiple times in the system, it’s a sign to use a dataclass or class instead of a `TypedDict`. This improves code readability and maintainability by grouping data with related logic.

**Why Dataclasses?** You should use dataclasses (or Pydantic models) for in-memory **domain objects that have invariants or behaviors**. Dataclasses make it easy to ensure the presence and type of fields at development time, and allow you to define utility methods/properties (like computing P\&L or validating values) that operate on that data. By marking them `frozen=True` (as you've done), you make these objects immutable value types, which is great for avoiding accidental modification of critical data (like an order or account state). The pattern in The Alchemiser is to parse raw dicts into dataclass models as soon as data enters the system, use the models throughout the business logic, and then convert back to dicts when outputting or serializing – continue following this pattern. For example, on receiving account info from Alpaca, convert it to an `AccountModel` for calculations, and only turn it back into an `AccountInfo` dict when you need to, say, send it over an API or save to JSON.

## Using Pydantic Models alongside TypedDict

Since you indicated you are using Pydantic, note that **Pydantic models can often serve as an enhanced alternative to plain dataclasses** in many places. You’ve already leveraged this for order validation and configuration. When using Pydantic `BaseModel` classes, you can still keep the `TypedDict` definitions for clarity and static typing at the boundaries, but you might not need them as much for purely internal data. For instance, if you define a `StrategySignalModel` as a Pydantic model instead of a vanilla dataclass, it could parse and validate any incoming dict of signal data automatically. In either case, the division of responsibility remains the same:

* **TypedDict** – for describing the schema of raw data (especially coming from or going out to external systems) and for allowing mypy to catch missing keys.
* **Dataclass/Pydantic** – for rich domain objects used in computation, with methods, validation, and type conversions.

In summary, **keep using `TypedDict` for data structures that are essentially *records or messages* (API inputs/outputs, config blobs, report entries)**, and **use `dataclasses` (or Pydantic models) for data that your code actively processes or enforces rules on**. This ensures you get the best of both: lightweight, typed containers for interchange, and robust, method-rich objects for your core logic. Following this approach in the `/the_alchemiser` folder, you’ll maintain clear boundaries – e.g., Alpaca API handlers produce `TypedDict` data which you immediately wrap into dataclass/Pydantic models for use in strategies and trading logic, then before sending out or saving, convert back to dict. Each existing case in the code fits this pattern, so an exhaustive breakdown is:

* **Remain as TypedDict:** `AccountInfo`, `PortfolioHistoryData`, `EnrichedAccountInfo`, `PositionInfo`, `OrderDetails`, `StrategySignal` (for raw signal dicts), `StrategyPnLSummary`, `KLMVariantResult`, `ExecutionResult`, `TradingPlan`, `QuoteData`, `LimitOrderResult`, `WebSocketResult`, `KLMDecision`, `ReportingData`, `DashboardMetrics`, `EmailReportData`, `MarketDataPoint`, `IndicatorData`, `PriceData`, `DataProviderResult`, `BacktestResult`, `PerformanceMetrics`, `TradeAnalysis`, `PortfolioSnapshot`, all `CLI*` types, `ErrorDetailInfo` and other error report types, `EmailCredentials`, `LambdaEvent`, etc. – these are primarily data schemas for I/O or aggregations.
* **Use Dataclass/Pydantic models:** `AccountModel` & `PortfolioHistoryModel`, `OrderModel` (and `ValidatedOrder` via Pydantic), `PositionModel`, `StrategySignalModel` & `StrategyPositionModel`, `BarModel`, `QuoteModel`, `PriceDataModel`, plus supporting classes like `RiskLimits/ValidationResult` (used in order validation) and any future classes that encapsulate logic (e.g. a future `ExecutionResultModel` if you decide to give methods to execution results). These should be used whenever the data needs to be treated as an object with behavior or needs validation beyond what static typing can ensure.

By applying this division consistently, you’ll make the codebase more maintainable: **TypedDicts** will clearly mark the structure of data exchanged at boundaries, and **dataclasses/Pydantic models** will provide a safe and convenient way to work with that data internally. This way, for example, your Alpaca API handlers in `/the_alchemiser` can output `AccountInfo` or `OrderDetails` dicts which you immediately load into `AccountModel`/`OrderModel` objects for use in portfolio calculations, risk checks, etc., and your strategy implementations can yield `StrategySignalModel` objects (constructed from indicator inputs) instead of raw dicts, improving type safety in the multi-strategy manager. Each piece of data in the system has a clear place: **if it’s mainly a data container -> TypedDict; if it’s an operational entity in code -> dataclass/Pydantic.** This approach is already evident in the code (e.g. order conversion and signal models), and extending it will ensure both reliability (with mypy checks on dicts) and clarity/robustness (with dataclass methods and Pydantic validation where needed).